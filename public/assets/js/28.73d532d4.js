(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{568:function(t,v,_){"use strict";_.r(v);var s=_(2),a=Object(s.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"_1、箭头函数和普通函数的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1、箭头函数和普通函数的区别"}},[t._v("#")]),t._v(" 1、箭头函数和普通函数的区别")]),t._v(" "),_("ol",[_("li",[t._v("箭头函数和普通函数的样式不同，箭头函数的语法更加简洁、清晰，箭头函数是"),_("code",[t._v("=>")]),t._v("定义函数，普通函数是"),_("code",[t._v("function")]),t._v("定义函数")]),t._v(" "),_("li",[t._v("箭头函数不能作为构造函数使用，也不能使用"),_("code",[t._v("new")]),t._v("关键字（```因为箭头函数中没有自己的this,它的this其实是继承了外层执行环境的this,且this指向是永远不会改变的，作为构造函数其他this要指向创建的新对象）")]),t._v(" "),_("li",[t._v("箭头函数的"),_("code",[t._v("this")]),t._v("是捕获它所在执行上下文的"),_("code",[t._v("this")]),t._v("来作为自己的this,定义的时候就确定了")]),t._v(" "),_("li",[t._v("箭头函数的"),_("code",[t._v("this")]),t._v("指向不会被"),_("code",[t._v("bind, call, apply")]),t._v("改变")]),t._v(" "),_("li",[t._v("箭头函数是没有自己的"),_("code",[t._v("arg")]),t._v("的。如果要访问则会得到外层函数执行的值。")]),t._v(" "),_("li",[t._v("箭头函数中没有"),_("code",[t._v("prototype")]),t._v("原型")])]),t._v(" "),_("h2",{attrs:{id:"_2、let、const、var这三者的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2、let、const、var这三者的区别"}},[t._v("#")]),t._v(" 2、let、const、var这三者的区别")]),t._v(" "),_("p",[_("strong",[t._v("变量提升:")])]),t._v(" "),_("ul",[_("li",[_("code",[t._v("var")]),t._v("声明的变量存在变量提升（变量可以在声明前调用，值为"),_("code",[t._v("undefined")]),t._v("）")]),t._v(" "),_("li",[_("code",[t._v("let")]),t._v("和"),_("code",[t._v("const")]),t._v("不存在变量提升问题（因为let和const都有一个暂时性死区的概念，所以在没有得到赋值前是不能被调用的）\n"),_("strong",[t._v("块级作用域：")]),t._v(" "),_("code",[t._v("var")]),t._v("不存在块级作用域，"),_("code",[t._v("let")]),t._v("和"),_("code",[t._v("const")]),t._v("存在块级作用域\n"),_("strong",[t._v("声明：")]),t._v(" "),_("code",[t._v("var")]),t._v("允许重复声明，"),_("code",[t._v("let")]),t._v("和"),_("code",[t._v("const")]),t._v("在同一作用域下不允许重复声明变量。"),_("code",[t._v("const")]),t._v("声明的是一个只读的常量，所以声明后就不能改变（如果声明的是一个对象，对象里的属性时可以改变的，因为"),_("code",[t._v("const")]),t._v("声明的对象只保存对象的引用地址，只要地址不发生改变，那么就不会报错）")])]),t._v(" "),_("h2",{attrs:{id:"_3、bigint和number的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3、bigint和number的区别"}},[t._v("#")]),t._v(" 3、Bigint和Number的区别")]),t._v(" "),_("ol",[_("li",[_("code",[t._v("Number")]),t._v("类型的数字有精度限制，数值的精度只能到53个二进制，大于这个范围的整数就无法精确表示了")]),t._v(" "),_("li",[_("code",[t._v("Bigint")]),t._v("没有位数限制，任何位数的整数都可以精确表示。但是只能用于表示整数，为了和"),_("code",[t._v("Number")]),t._v("区分，"),_("code",[t._v("Bigint")]),t._v("类型的数据后面必须加后缀"),_("code",[t._v("n")]),t._v("。"),_("code",[t._v("Bigint")]),t._v("可以使用负号却不能使用正号。")]),t._v(" "),_("li",[t._v("二者类型的数据不能或者计算")])]),t._v(" "),_("h2",{attrs:{id:"_4、基本数据类型和引用数据类型的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4、基本数据类型和引用数据类型的区别"}},[t._v("#")]),t._v(" 4、基本数据类型和引用数据类型的区别")]),t._v(" "),_("p",[_("strong",[t._v("基本数据类型：")])]),t._v(" "),_("ol",[_("li",[t._v("基本数据类型的值是不可变的（重新赋值属于改变属性名指向，而不是对值进行操作）")])]),t._v(" "),_("div",{staticClass:"language-js line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-js"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" str "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token string"}},[t._v("'abc'")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nstr"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),_("span",{pre:!0,attrs:{class:"token function"}},[t._v("split")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token string"}},[t._v("''")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nconsole"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),_("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// abc")]),t._v("\n")])]),t._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[t._v("1")]),_("br"),_("span",{staticClass:"line-number"},[t._v("2")]),_("br"),_("span",{staticClass:"line-number"},[t._v("3")]),_("br")])]),_("ol",{attrs:{start:"2"}},[_("li",[t._v("基本数据类型不可以添加属性和方法")]),t._v(" "),_("li",[t._v("基本数据类型的赋值是简单赋值，基本数据类型的比较是值的比较")]),t._v(" "),_("li",[t._v("基本数据类型的存放在"),_("code",[t._v("栈")]),t._v("里面的")])]),t._v(" "),_("p",[_("strong",[t._v("引用数据类型：")])]),t._v(" "),_("ol",[_("li",[t._v("引用数据类型的值是可以改变的")]),t._v(" "),_("li",[t._v("引用类型可以添加属性和方法")]),t._v(" "),_("li",[t._v("引用类型的赋值是对象引用，即声明的变量标识符，存储的只是对象的指针地址")]),t._v(" "),_("li",[t._v("引用类型的比较是引用"),_("code",[t._v("指针地址")]),t._v("的比较")]),t._v(" "),_("li",[t._v("引用类型是同时保存在"),_("code",[t._v("栈")]),t._v("和"),_("code",[t._v("堆")]),t._v("中的，栈中保存变量标识符和指向堆的地址")])])])}),[],!1,null,null,null);v.default=a.exports}}]);