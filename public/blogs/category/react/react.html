<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>react | 林深的博客</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="林深的博客">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.5f4785e5.css" as="style"><link rel="preload" href="/assets/js/app.c57aec4d.js" as="script"><link rel="preload" href="/assets/js/4.b5d4bb75.js" as="script"><link rel="preload" href="/assets/js/1.38fca83b.js" as="script"><link rel="preload" href="/assets/js/14.6044522d.js" as="script"><link rel="prefetch" href="/assets/js/10.ab5c93b4.js"><link rel="prefetch" href="/assets/js/11.cea08b9b.js"><link rel="prefetch" href="/assets/js/12.98109e82.js"><link rel="prefetch" href="/assets/js/13.0ef328ec.js"><link rel="prefetch" href="/assets/js/15.0626c520.js"><link rel="prefetch" href="/assets/js/16.d5c283ca.js"><link rel="prefetch" href="/assets/js/17.f59c9a14.js"><link rel="prefetch" href="/assets/js/18.d47a1c53.js"><link rel="prefetch" href="/assets/js/19.7e6c0d50.js"><link rel="prefetch" href="/assets/js/20.bd8f980a.js"><link rel="prefetch" href="/assets/js/21.b01ed671.js"><link rel="prefetch" href="/assets/js/22.54639c84.js"><link rel="prefetch" href="/assets/js/23.c4c3de06.js"><link rel="prefetch" href="/assets/js/24.83abc585.js"><link rel="prefetch" href="/assets/js/25.1165290b.js"><link rel="prefetch" href="/assets/js/26.5d531519.js"><link rel="prefetch" href="/assets/js/27.db0793ab.js"><link rel="prefetch" href="/assets/js/28.1d45e297.js"><link rel="prefetch" href="/assets/js/29.d7269b41.js"><link rel="prefetch" href="/assets/js/30.5edaba80.js"><link rel="prefetch" href="/assets/js/31.0ce0f650.js"><link rel="prefetch" href="/assets/js/32.a437ae8f.js"><link rel="prefetch" href="/assets/js/33.f98be2bd.js"><link rel="prefetch" href="/assets/js/5.b58a7347.js"><link rel="prefetch" href="/assets/js/6.65f13f2f.js"><link rel="prefetch" href="/assets/js/7.6602d270.js"><link rel="prefetch" href="/assets/js/8.2d0891a7.js"><link rel="prefetch" href="/assets/js/9.618ac51f.js"><link rel="prefetch" href="/assets/js/vendors~flowchart.10d5f383.js">
    <link rel="stylesheet" href="/assets/css/0.styles.5f4785e5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-1156296a><div data-v-1156296a><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-1156296a data-v-1156296a><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-4e82dffc data-v-1156296a data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>林深的博客</h3> <p class="description" data-v-4e82dffc data-v-4e82dffc>林深的博客</p> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><span data-v-4e82dffc>林深</span>
            
          <!---->
          2021
        </a></span></div></div> <div class="hide" data-v-1156296a><header class="navbar" data-v-1156296a><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.png" alt="林深的博客" class="logo"> <span class="site-name">林深的博客</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/TypeScript/" class="nav-link"><i class="undefined"></i>
  TypeScript
</a></li><li class="dropdown-item"><!----> <a href="/categories/react-config-module/" class="nav-link"><i class="undefined"></i>
  react-config-module
</a></li><li class="dropdown-item"><!----> <a href="/categories/react/" class="nav-link"><i class="undefined"></i>
  react
</a></li><li class="dropdown-item"><!----> <a href="/categories/随笔/" class="nav-link"><i class="undefined"></i>
  随笔
</a></li><li class="dropdown-item"><!----> <a href="/categories/面试/" class="nav-link"><i class="undefined"></i>
  面试
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  文档历史
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      链接
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-1156296a></div> <aside class="sidebar" data-v-1156296a><div class="personal-info-wrapper" data-v-828910c6 data-v-1156296a><img src="/avatar.jpeg" alt="author-avatar" class="personal-img" data-v-828910c6> <h3 class="name" data-v-828910c6>
    林深
  </h3> <div class="num" data-v-828910c6><div data-v-828910c6><h3 data-v-828910c6>21</h3> <h6 data-v-828910c6>Articles</h6></div> <div data-v-828910c6><h3 data-v-828910c6>4</h3> <h6 data-v-828910c6>Tags</h6></div></div> <ul class="social-links" data-v-828910c6></ul> <hr data-v-828910c6></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/TypeScript/" class="nav-link"><i class="undefined"></i>
  TypeScript
</a></li><li class="dropdown-item"><!----> <a href="/categories/react-config-module/" class="nav-link"><i class="undefined"></i>
  react-config-module
</a></li><li class="dropdown-item"><!----> <a href="/categories/react/" class="nav-link"><i class="undefined"></i>
  react
</a></li><li class="dropdown-item"><!----> <a href="/categories/随笔/" class="nav-link"><i class="undefined"></i>
  随笔
</a></li><li class="dropdown-item"><!----> <a href="/categories/面试/" class="nav-link"><i class="undefined"></i>
  面试
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  文档历史
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      链接
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>React</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blogs/category/react/configReactProduct.html" class="sidebar-link">配置eslint和less module</a></li><li><a href="/blogs/category/react/react.html" aria-current="page" class="active sidebar-link">react</a></li><li><a href="/blogs/category/react/reactHooks.html" class="sidebar-link">react-hooks</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-4e82dffc data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>react</h3> <!----> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><span data-v-4e82dffc>林深</span>
            
          <!---->
          2021
        </a></span></div></div> <div data-v-1156296a><main class="page" style="padding-right:0;"><section><div class="page-title"><h1 class="title">react</h1> <div data-v-1ff7123e><i class="iconfont reco-account" data-v-1ff7123e><span data-v-1ff7123e>林深</span></i> <i class="iconfont reco-date" data-v-1ff7123e><span data-v-1ff7123e>5/15/2021</span></i> <!----> <i class="tags iconfont reco-tag" data-v-1ff7123e><span class="tag-item" data-v-1ff7123e>react</span></i></div></div> <div class="theme-reco-content content__default"><h2 id="组件基础"><a href="#组件基础" class="header-anchor">#</a> 组件基础</h2> <h3 id="_1、react事件绑定原理"><a href="#_1、react事件绑定原理" class="header-anchor">#</a> 1、react事件绑定原理</h3> <div class="language-typescript jsx line-numbers-mode"><pre class="language-typescript"><code><span class="token operator">&lt;</span>div onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleClick<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>react 并不是将<code>click</code>事件绑定到了<code>div</code>真实的<code>DOM</code>上，而是在<code>document</code>处监听了所有的事件，当事件发生并且冒泡到<code>document</code>处的时候，
react 将事件内容封装并交由真正的处理函数执行。这样的方式不仅仅减少了内存的消耗，还能在组件挂载销毁时统一订阅和移除事件。</p> <p>还有， 冒泡到<code>document</code>上的事件也不是原生的浏览器事件，而是由react自己合成的事件，所以不想要事件冒泡的话应该调用<code>event.preventDefault()</code>方法，而
不是调用<code>event.stopProppagation()</code>方法</p> <h3 id="_2、react的事件和普通的html事件有什么不同"><a href="#_2、react的事件和普通的html事件有什么不同" class="header-anchor">#</a> 2、React的事件和普通的HTML事件有什么不同？</h3> <h4 id="区别"><a href="#区别" class="header-anchor">#</a> 区别：</h4> <ol><li>对于事件名称的命名方式，原生事件为全小写，而react 事件采用小驼峰</li> <li>对于事件函数处理语法，原生事件为字符串，react 事件为函数</li> <li>react 事件不能采取<code>return false</code>的方法来阻止浏览器的默认行为，而必须要地明确地调用<code>preventDefault()</code>来阻止默认行为</li></ol> <h3 id="合成事件是-react-模拟原生-dom-事件所有能力的一个事件对象-优点"><a href="#合成事件是-react-模拟原生-dom-事件所有能力的一个事件对象-优点" class="header-anchor">#</a> 合成事件是 react 模拟原生 DOM 事件所有能力的一个事件对象 优点</h3> <ol><li>兼容所有的浏览器，更好的跨平台</li> <li>将事件统一存放在一个数组，避免频繁的新增和删除（垃圾回收）</li> <li>方便react统一管理和事件机制</li></ol> <h3 id="_3、-react-组件中怎么做事件代理-它的原理是什么"><a href="#_3、-react-组件中怎么做事件代理-它的原理是什么" class="header-anchor">#</a> 3、 React 组件中怎么做事件代理？它的原理是什么？</h3> <p>react基于<code>Virtual DOM</code>实现一个<code>事件合成层</code>，定义的事件处理器会接收到一个合成事件对象的实例。它符合W3CW标准，且与原生浏览器事件有相同的接口。
支持冒泡事件，所有的事件都自动绑定在最外层。</p> <h4 id="在react底层-主要对合成事件做了-事件委派和自动绑定。"><a href="#在react底层-主要对合成事件做了-事件委派和自动绑定。" class="header-anchor">#</a> 在React底层，主要对合成事件做了：事件委派和自动绑定。</h4> <ul><li><strong>事件委派：</strong> react会把所有事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上w维持了一个映射来保存s所有组件内部事件监听和处理函数</li> <li><strong>自动绑定：</strong> react组件中，每个方法的上下文都对指向该组件的实例，即自动绑定 <strong>this</strong> 为当前组件</li></ul> <h3 id="_4、react-高阶组件、render-props、hooks-有什么区别-为什么要不断迭代"><a href="#_4、react-高阶组件、render-props、hooks-有什么区别-为什么要不断迭代" class="header-anchor">#</a> 4、React 高阶组件、Render props、hooks 有什么区别，为什么要不断迭代</h3> <p><strong>这三个是目前react解决代码复用的主要方式。</strong></p> <ul><li>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。具体而言，高阶组件是参数为组件，返回值为新组件的函数。</li> <li>render props是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术，更具体的说，render prop 是一个用于告知组件需要渲染什么内容的函数 prop。</li> <li>通常，render props 和高阶组件只渲染一个子节点。让 Hook 来服务这个使用场景更加简单。这两种模式仍有用武之地，（例如，一个虚拟滚动条组件或许会有一个 <code>renderltem</code> 属性，或是一个可见的容器组件或许会有它自己的 DOM 结构）。但在大部分场景下，<code>Hook</code> 足够了，并且能够帮助减少嵌套。</li></ul> <p><strong>HOC 官方解释∶</strong></p> <div class="language- extra-class"><pre><code>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。
HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。
</code></pre></div><p><strong>简单的来说，HOC是一种组件的设计模式，HOC接受一个组件和额外的参数（如果需要），返回一个新的组件。HOC 是纯函数，没有副作用。</strong></p> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token comment">// hoc的定义</span>
<span class="token keyword">function</span> <span class="token function">withSubscription</span><span class="token punctuation">(</span><span class="token parameter">WrappedComponent<span class="token punctuation">,</span> selectData</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> React<span class="token punctuation">.</span>Component <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
        data<span class="token operator">:</span> <span class="token function">selectData</span><span class="token punctuation">(</span>DataSource<span class="token punctuation">,</span> props<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 一些通用的逻辑处理</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// ... 并使用新数据渲染被包装的组件!</span>
      <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">WrappedComponent</span></span> <span class="token attr-name">data</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>data<span class="token punctuation">}</span></span> <span class="token spread"><span class="token punctuation">{</span><span class="token punctuation">...</span><span class="token attr-value">this</span><span class="token punctuation">.</span><span class="token attr-value">props</span><span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 使用</span>
<span class="token keyword">const</span> BlogPostWithSubscription <span class="token operator">=</span> <span class="token function">withSubscription</span><span class="token punctuation">(</span>BlogPost<span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token parameter">DataSource<span class="token punctuation">,</span> props</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> DataSource<span class="token punctuation">.</span><span class="token function">getBlogPost</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><h4 id="hoc的优缺点∶"><a href="#hoc的优缺点∶" class="header-anchor">#</a> hoc的优缺点∶</h4> <ul><li>优点∶ 逻辑服用、不影响被包裹组件的内部逻辑</li> <li>缺点：hoc传递给被包裹组件的props容易和被包裹后的组件重名，进而被覆盖</li></ul> <h4 id="render-props-官方解释∶"><a href="#render-props-官方解释∶" class="header-anchor">#</a> Render props 官方解释∶</h4> <div class="language- extra-class"><pre><code>”render prop”是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术
</code></pre></div><p>具有<code>render prop</code> 的组件接受一个返回 <strong>react</strong> 元素的函数，将render的渲染逻辑注入到组件内部，在这里 <strong>render</strong> 的命名
可以使其他有效的标识符</p> <div class="language-typescript jsx line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// DataProvider组件内部的渲染逻辑如下</span>
<span class="token keyword">class</span> <span class="token class-name">DataProvider</span> <span class="token keyword">extends</span> <span class="token class-name">React</span><span class="token punctuation">.</span>Components <span class="token punctuation">{</span>
     state <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">'Tom'</span>
  <span class="token punctuation">}</span>

    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
        <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
          <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>共享数据组件自己内部的渲染逻辑<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
          <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">)</span> <span class="token punctuation">}</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 调用方式</span>
<span class="token operator">&lt;</span>DataProvider render<span class="token operator">=</span><span class="token punctuation">{</span>data <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>
  <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>Hello <span class="token punctuation">{</span>data<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><h4 id="由此可以看到-render-props的优缺点也很明显∶"><a href="#由此可以看到-render-props的优缺点也很明显∶" class="header-anchor">#</a> 由此可以看到，render props的优缺点也很明显∶</h4> <ul><li>优点：数据共享、代码复用，将组件内的state作为props传递给调用者，将渲染逻辑交给调用者。</li> <li>缺点：无法在 return 语句外访问数据、嵌套写法不够优雅</li></ul> <h4 id="hooks-官方解释∶"><a href="#hooks-官方解释∶" class="header-anchor">#</a> Hooks 官方解释∶</h4> <div class="language- extra-class"><pre><code>Hook是 React 16.8 的新增特性。
它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。
通过自定义hook，可以复用代码逻辑。
</code></pre></div><div class="language-typescript jsx line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// 自定义一个获取订阅数据的hook</span>
<span class="token keyword">function</span> <span class="token function">useSubscription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> data <span class="token operator">=</span> DataSource<span class="token punctuation">.</span><span class="token function">getComments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span>data<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// </span>
<span class="token keyword">function</span> <span class="token function">CommentList</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span>data<span class="token punctuation">}</span> <span class="token operator">=</span> props<span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>subData<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useSubscription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">...</span>
<span class="token punctuation">}</span>
<span class="token comment">// 使用</span>
<span class="token operator">&lt;</span>CommentList data<span class="token operator">=</span><span class="token string">'hello'</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>以上可以看出，hook解决了hoc的prop覆盖的问题，同时使用的方式解决了render props的嵌套地狱的问题。hook的优点如下∶</p> <ul><li>使用直观</li> <li>解决hoc的prop 重名问题</li> <li>解决render props 因共享数据 而出现嵌套地狱的问题</li> <li>能在return之外使用数据的问题</li></ul> <p>需要注意的是∶hook只能在组件顶层使用，不可在分支语句中使用。</p> <p><strong>总结：</strong> Hoc、render props和hook都是为了解决代码复用的问题，但是hoc和render props都有特定的使用场景和明显的缺点。hook是react16.8更新的新的API，让组件逻辑复用更简洁明了，同时也解决了hoc和render props的一些缺点。</p> <h3 id="_5、对react-fiber的理解-它解决了什么问题"><a href="#_5、对react-fiber的理解-它解决了什么问题" class="header-anchor">#</a> 5、对React-Fiber的理解，它解决了什么问题？</h3> <p>React V15 在渲染时，会递归比对 VirtualDOM 树，找出需要变动的节点，然后同步更新它们， 一气呵成。这个过程期间， React 会占据浏览器资源，这会导致用户触发的事件得不到响应，并且会导致掉帧，
<strong>导致用户感觉到卡顿</strong></p> <p>为了给用户制造一种应用很快的“假象”，不能让一个任务长期霸占着资源。 可以将浏览器的渲染、布局、绘制、资源加载(例如 HTML 解析)、事件响应、脚本执行视作操作系统的“进程”，需要通过某些调度策略合理地分配 CPU 资源，从而提高浏览器的用户响应速率, 同时兼顾任务执行效率。</p> <p>所以 React 通过Fiber 架构，让这个执行过程变成可被中断。“适时”地让出 CPU 执行权，除了可以让浏览器及时地响应用户的交互，还有其他好处:</p> <ul><li>分批延时对DOM进行操作，避免一次性操作大量 DOM 节点，可以得到更好的用户体验；</li> <li>给浏览器一点喘息的机会，它会对代码进行编译优化（JIT）及进行热代码优化，或者对 reflow 进行修正。__核心思想：__Fiber 也称协程、或者纤程。它和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制。
让出 CPU 的执行权，让 CPU 能在这段时间执行其他的操作。渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染。</li></ul> <h3 id="_6、react-component-和-react-purecomponent-的区别"><a href="#_6、react-component-和-react-purecomponent-的区别" class="header-anchor">#</a> 6、React.Component 和 React.PureComponent 的区别？</h3> <p>pureComponent表示一个纯组件，可以用来优化react组件，减少render函数执行的次数，从而提高组件的性能</p> <p>在react中，当<code>props</code>或<code>state</code>发生变化时，可以通过在<code>shouldComponentUpdate</code>生命周期函数中执行<code>return false</code>来阻止页面的更新，从而减少不必要的render执行。React.PureComponent会自动执行 shouldComponentUpdate。</p> <p>不过，pureComponent中的<code>shouldComponentUpdate()</code>进行的是 <strong>浅比较</strong> ，也就是说如果是 <strong>引用类型数据</strong> ,只会比较不是同一个地址，而不会比较这个地址里面的数据是否一致。浅比较会忽略属性或状态突变情况。其实也就是数据引用指针没有变化。而数据发生改变的时候render是不会执行的。
如果需要重新渲染那么就需要重新开辟空间引用数据。PureComponent一般会用在一些纯展示组件上。</p> <h4 id="使用purecomponent的好处"><a href="#使用purecomponent的好处" class="header-anchor">#</a> 使用pureComponent的好处：</h4> <p>当组件更新时，如果组件的props或state没有改变，render函数就不会触发。省去虚拟dom的生成和对比过程，达到提升性能的目的。这是因为react自动做了一层浅比较。</p> <h3 id="_7、component-element-instance-之间有什么区别和联系"><a href="#_7、component-element-instance-之间有什么区别和联系" class="header-anchor">#</a> 7、Component, Element, Instance 之间有什么区别和联系？</h3> <p><strong>元素:</strong> 一个元素element是一个普通对象，描述了对于一个DOM节点或者其他组件component,你想让他在屏幕中呈现什么样子。素element可以在它的属性props中包含其他元素(译注:用于形成元素树)。创建一个React元素element成本很低。元素element创建之后是不可变的。</p> <p><strong>组件：</strong> 一个组件component可以通过多种方式声明。可以是带有一个render()方法的类，简单点也可以定义为一个函数。这两种情况下，它都把属性props作为输入，把返回的一棵元素树作为输出。</p> <p><strong>实例：</strong> 一个实例instance是你在所写的组件类<code>component class</code>中使用关键字this所指向的东西(译注:组件实例)。它用来存储本地状态和响应生命周期事件很有用。</p> <p>函数试组件根本没有instance实例，类组件有实例，但是永远也不要直接创建一个组件的实例，因为react已经帮我们做了这些。</p> <h3 id="_8、对componentwillreceiveprops-的理解"><a href="#_8、对componentwillreceiveprops-的理解" class="header-anchor">#</a> 8、对componentWillReceiveProps 的理解</h3> <p>该生命周期函数只有在props发生变化时执行，初始化render时不执行，在这个回调函数里面，你可以根据属性的变化，通过调用<code>this.setState()</code>来更新你的组件状态，旧的属性还是可以通过<code>this.props</code>来获取，这里调用更新状态是安全的。并不会触发额外的render调用。</p> <p><strong>使用好处：</strong> 在这个生命周期中，可以在子组件的render函数执行前获取新的props，从而更新子组件自己的state。可以将数据请求放在这里进行执行，需要传的参数则从<code>componentWillReceiveProps(nextProps)</code>中获取。而不必将所有的请求都放在父组件中。于是该请求只会在该组件渲染时才会发出，从而减轻请求负担。<code>componentWillReceiveProps(nextProps)</code>在初始化render的时候不会执行，它会在component接收到新的props（状态）时被触发，一遍用于父组件状态更新时子组件重新渲染。</p> <h3 id="_9、哪些方法会触发-react-重新渲染-重新渲染-render-会做些什么"><a href="#_9、哪些方法会触发-react-重新渲染-重新渲染-render-会做些什么" class="header-anchor">#</a> 9、哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？</h3> <p><strong>1、哪些方法会触发 react 重新渲染?</strong></p> <ul><li>setState()方法被调用</li></ul> <p>setState是react中最常用的命令，通常情况下，执行setState会触发render。但是这里有个点需要注意一下，执行setState的时候一定会重新渲染吗？答案是不一定，当setState传入null的时候，并不会触发render。</p> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  state <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token operator">:</span> <span class="token number">1</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;render&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">React.Fragement</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>a<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span>
          <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这里并没有改变 a 的值</span>
          <span class="token punctuation">}</span><span class="token punctuation">}</span></span>
        <span class="token punctuation">&gt;</span></span><span class="token plain-text">
          Click me
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">setState null</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Child</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">React.Fragement</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><ul><li>父组件重新渲染
只有父组件重新渲染了，即使传入子组件的props未发生变化，那么子组件也会重新渲染，进而触发render</li></ul> <p><strong>2、重新渲染render会做些什么？</strong></p> <ul><li>会对新旧Vnode进行对比，也就是我们所说的diff算法</li> <li>对新旧两颗树进行一个深度优先遍历，这样每一个节点都会有一个标记，在到深度遍历的时候，每遍历到一个节点。就把该节点和新的节点树进行对比，如果有差异就放到一个对象里面</li> <li>遍历差异对象，根据差异的类型，根据应对规则更新Vnode</li></ul> <p>react的处理Render的基本思维模式是每次一有变动就会去重新渲染整个应用。在虚拟dom没出现之前，最简单的方法就是直接调用innerHTML。虚拟dom厉害的地方并不是说他比直接操作dom快，而是说不管数据怎么变，都会尽量以最小的代价去更新dom，react将render函数返回的虚拟dom树与老的进行比较，从而确定dom要不要更新、怎么更新。当DOM树很大时，遍历两棵树进行各种比对是相当耗性能的，特别是在顶层setState一个微小的修改，默认回去遍历整颗树。尽管react使用高度优化的diff算法，但是这个过程仍会损耗性能。</p> <h3 id="_10、react如何判断什么时候重新渲染组件"><a href="#_10、react如何判断什么时候重新渲染组件" class="header-anchor">#</a> 10、React如何判断什么时候重新渲染组件？</h3> <p>组件状态的改变可以因为props的改变，或者直接通过setState方法改变。组件获得新的状态然后React决定是否应该重新渲染组件。只要组件的State发生变化，react就会对组件进行重新渲染。这是因为react中的<code>shouldComponentUpdate</code>方法默认返回 <code>true</code>，这就是导致每次更新都重新渲染的原因。</p> <p>当react将要渲染组件时会执行<code>shouldComponentUpdate</code>方法来看它是否返回true（组件应该更新，也就是重新渲染）。所以需要重写<code>shouldComponentUpdate</code>方法让它根据情况返回true或者false来告诉React什么时候重新渲染什么时候跳过重新渲染。</p> <h3 id="_11、对有状态组件和无状态组件的理解及使用场景"><a href="#_11、对有状态组件和无状态组件的理解及使用场景" class="header-anchor">#</a> 11、对有状态组件和无状态组件的理解及使用场景</h3> <p><strong>有状态组件 特点：</strong></p> <ul><li>是一个类组件、有继承、可以使用this</li> <li>可以使用react的生命周期</li> <li>使用较多，容易频繁触发生命周期钩子函数，影响性能</li> <li>内部使用state,维护自身状态的变化，有状态组件根据外部组件传入的props和自身的State进行渲染</li></ul> <p><strong>使用场景</strong></p> <ul><li>需要使用到状态的</li> <li>需要使用状态操作组件的（无状态组件的也可以实现新版本react hooks也可以实现）</li></ul> <p><strong>总结：</strong>
类组件可以维护自身的状态变量，即组件的state,类组件还有不同的生命周期方法，可以让开发者能够在组件的不同阶段（挂载、更新、卸载），对组件做更多的控制。类组件既可以充当无状态组件，也可以充当有状态组件。当一个类组件不需要管理自身状态时，也可以被称为无状态组件。</p> <p><strong>无状态组件  特点</strong></p> <ul><li>不依赖自身的状态state</li> <li>可以使类组件或者函数组件</li> <li>可以完全避免使用<code>this</code>关键字（由于使用的是箭头函数无需绑定）</li> <li>有更高的性能。当不需要使用生命周期钩子时，应该首先使用无状态组件</li> <li>组件内部不维护state，只根据外部组件传入的props进行渲染的组件，当props改变时，组件重新渲染</li></ul> <p><strong>使用场景</strong></p> <ul><li>组件不需要管理state，纯展示</li></ul> <p><strong>有点</strong></p> <ul><li>简化代码，专注render</li> <li>组件不需要被实例化，无生命周期，提高性能。渲染只取决于属性，无副作用</li> <li>视图和数据的解耦分离</li></ul> <p><strong>缺点</strong></p> <ul><li>无法使用ref和生命周期方法</li> <li>无法控制组件的重渲染，因为无法使用<code>shouldComponentUpdate</code>方法，当组件接收到的属性时则会冲渲染</li></ul> <p><strong>总结：</strong>
组件内部状态且与外部无关的组件，可以考虑用五状态组件，这样状态数就不会过于复杂，易于理解和管理。当一个组件不需要管理自身状态时，也就是无状态组件，应该优先设计为函数组件。</p> <h3 id="_12、对react中fragment的理解-它的使用场景是什么"><a href="#_12、对react中fragment的理解-它的使用场景是什么" class="header-anchor">#</a> 12、对React中Fragment的理解，它的使用场景是什么？</h3> <p>在react中，组件返回的元素只能有一个根元素。为了不添加多余的dom节点，我们可以使用<code>Fragment</code>标签来包裹所有的元素，Fragment标签不会渲染出任何元素。</p> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> Component<span class="token punctuation">,</span> Fragment <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span>

<span class="token comment">// 一般形式</span>
<span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">React.Fragment</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ChildA</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ChildB</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ChildC</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">React.Fragment</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 也可以写成以下形式</span>
<span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ChildA</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ChildB</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ChildC</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><h3 id="_13、在react中如何避免不必要的render"><a href="#_13、在react中如何避免不必要的render" class="header-anchor">#</a> 13、在React中如何避免不必要的render？</h3> <p>React基于虚拟DOM和高效diff算法的完美配合，实现了对DOM最小粒度的更新。大多情况下，react对DOM的渲染效率足以业务日常。但在个别复杂业务场景下，性能问题依然存在。此时需要采取一些措施来提升运行性能，其很重要的一个方向就是尽可能的避免<code>render</code></p> <ul><li>shouldComponentUpdate和PureComponent</li></ul> <p>在react类组件中，可以利用<code>shouldComponentUpdate</code>或者<code>pureComponent</code>来减少因父组件更新而触发子组件render，从而达到目的。<code>shouldComponentUpdate</code>来决定是否组件是否重新渲染，如果不希望组件重新渲染，返回<code>false</code>即可。</p> <ul><li>利用高阶组件</li></ul> <p>在函数组件中，并没有 <code>shouldComponentUpdate</code>这个生命周期，可以利用高阶组件，封装一个类似<code>PureComponet</code>的功能</p> <ul><li>使用React.memo</li></ul> <p>React.mome是react<code>16.0</code>新的一个API，用来缓存组件的渲染，避免不必要的更新，其实也会死你一个高阶组件，与<code>PureComponent</code>十分类似，但不同的是<code>React.memo</code>只能用于函数组件。</p> <h3 id="_14、对-react-context-的理解"><a href="#_14、对-react-context-的理解" class="header-anchor">#</a> 14、对 React context 的理解</h3> <p>在React中， 数据传递一般使用props传递数据，维持单项数据流，这样可以让组件之间的关系变得简单可预测，但是单向数据流在某些场景中并不适用。单纯一对的父子组件传递并无问题，但要是组件之间层层依赖深入，<code>props</code>就需要层层传递，显然这样做太繁琐了。</p> <p><code>Context</code>提供了一种在组件之间共享此类值得方法，而不必显式的通过组件树的逐层传递 <code>props</code></p> <p>可以把<code>context</code>当做是特定一个组件数内共享的<code>store</code>，用来做数据传递。<code>简单的说就是，当年你不想在组件树中通过逐层传递props或者state的方式来传递数据时，可以使用Context来实现跨层级的组件数据传递。</code></p> <p>js的代码在执行期间，会创建一个相应的作用域链，这个作用域链记录这运行时js代码块执行期间所能访问的活动对象，包括变量和函数，js程序通过作用域链访问到代码块内部或者外部的变量和函数</p> <p>假如以js的作用域链作为类比，react组件提供的context对象其实就是好比一个提供给子组件访问的作用域，而Context对象的属性可以看成作用域上的活动对象。由于组件的context由父节点链上所有组件通过<code>getChildContext（）</code>返回的context对象组合而成，所以组件通过context是可以访问到其父组件链上所有节点组件提供的context的属性。</p> <h3 id="_15、为什么react并不推荐优先考虑使用context"><a href="#_15、为什么react并不推荐优先考虑使用context" class="header-anchor">#</a> 15、为什么React并不推荐优先考虑使用Context？</h3> <ul><li><p>context目前还处于实验阶段，可能会在后面发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来的影响和麻烦，不建议在app中使用context。</p></li> <li><p>尽管不建议在app中使用context，但是独有组件而言，由于影响范围小于app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用context；</p></li> <li><p>对于组件之间的数据通信或者状态管理，有效使用props或者State解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳方案的时候，考虑context</p></li> <li><p>context的更新需要通过<code>setState()</code>触发，但是这并不是可靠的，context支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如<code>shouldComponentUpdate()</code>返回<code>false</code>那么不能保证context的更新一定可以使用context的子组件，因此，context的可靠性需要关注</p></li></ul> <h3 id="_16、react中refs的作用是什么-有哪些应用场景"><a href="#_16、react中refs的作用是什么-有哪些应用场景" class="header-anchor">#</a> 16、React中refs的作用是什么？有哪些应用场景？</h3> <p>Refs提供了一种方式，用于访问在 <code>render</code>方法中创建的<code>react</code>元素或<code>DOM</code>节点，refs应该谨慎使用，如下场景使用refs比较适合：</p> <ul><li>处理焦点、文本选择或者媒体的控制</li> <li>触发必要的动画</li> <li>集成第三方DOM库</li></ul> <p><strong>注意：</strong></p> <ul><li>不应该国度的使用refs</li> <li>ref的返回值取决于节点的类型</li></ul> <ol><li>当ref属性被用于一个普通的<code>HTML</code>元素时，<code>react.createRef()</code>将接收底层<code>DOM</code>元素作为它的<code>current</code>属性以创建ref。</li> <li>当ref属性被用于一个自定义的类组件时，ref对象将接收该组件已挂载的实例作为它的<code>current</code></li></ol> <ul><li>当在父组件中需要访问子组件中的ref时可使用传递refs或回调refs。</li></ul> <h3 id="_17、react组件的构造函数有什么作用-它是必须的吗"><a href="#_17、react组件的构造函数有什么作用-它是必须的吗" class="header-anchor">#</a> 17、React组件的构造函数有什么作用？它是必须的吗？</h3> <p>构造函数主要用于两个目的：</p> <ul><li>通过将对象分配给<code>this.state</code>来初始化本地状态</li> <li>将事件处理程序方法绑定到实例上</li></ul> <p>所以，当在React class中需要设置state的初始值或者绑定事件时，需要加上构造函数，官方Demo:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">LikeButton</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
      liked<span class="token operator">:</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>handleClick <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleClick</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>liked<span class="token operator">:</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>liked<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> text <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>liked <span class="token operator">?</span> <span class="token string">'liked'</span> <span class="token operator">:</span> <span class="token string">'haven\'t liked'</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleClick<span class="token punctuation">}</span><span class="token operator">&gt;</span>
        You <span class="token punctuation">{</span>text<span class="token punctuation">}</span> <span class="token keyword">this</span><span class="token punctuation">.</span> Click to toggle<span class="token punctuation">.</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>
  <span class="token operator">&lt;</span>LikeButton <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
  document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'example'</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>构造函数用来新建父类的<code>this</code>对象；子类必须在<code>constructor</code>方法中调用<code>super</code>方法；否则新建实例时会报错；因为子类没有自己的<code>this</code>对象，而是继承父类的<code>this</code>对象，然后对其进行加工。如果不调用<code>super</code>方法；子类就得不到<code>this</code>对象。</p> <p><strong>注意：</strong></p> <ul><li>constructor() 必须配上super()，如果要在constructor内部使用<code>this.props</code>就要传入<code>props</code>，否则不用</li> <li>js中的<code>bind</code>每次都会返回一个新的函数，为了性能等考虑，尽量在<code>constructor</code>中绑定事件</li></ul> <h3 id="_18、react-forwardref是什么-它有什么作用"><a href="#_18、react-forwardref是什么-它有什么作用" class="header-anchor">#</a> 18、React.forwardRef是什么？它有什么作用？</h3> <p>React.forwardRef会创建一个react组件，这个组件能够将其接受的<code>ref</code>属性转发到其组件树下的另一个组件中。这种技术并不常见，实例</p> <ul><li>转发ref到DOM组件</li> <li>在高阶组件中转发refs</li></ul> <h3 id="_19、类组件与函数组件有什么异同"><a href="#_19、类组件与函数组件有什么异同" class="header-anchor">#</a> 19、类组件与函数组件有什么异同？</h3> <p><strong>相同点：</strong> 组件是react可复用的最小代码片段，他们会在页面中渲染的react元素，也正因为组件是react的最小编码单位，所以无论是函数组件还是类组件，在使用方法和最终呈现效果上是完全一致的。</p> <p>我们可以将一个类组件改写成函数组件，或者把一个函数组件改写成类组件（虽然并不推荐这种重构行为）。从使用者的角度而言，很难从体验上区分两者，而且在现代浏览器中，闭包和类的性能只能在极端场景下才会有明显的差别。</p> <p>所以，基本可认为两者作为组件是完全一致的。</p> <p><strong>不同点：</strong></p> <ul><li>它们在开发时的心智模型上却存在巨大差异。类组件时基于面向对象编程的，它主打的是继承、生命周期等核心概念；而函数组件内核是函数式编程，主打的是<code>immutable</code>、没有副作用、引用透明等特点。</li> <li>之前，在使用的场景上，如果存在需要使用生命周期的组件，那么主推类组件；设计模式上，如果需要使用继承，那么主推类组件。但现在由于<code>react hooks</code>的推出，生命周期概念的淡出，函数组件可以完全取代类组件。其次继承并不是组件最佳的设计模式，官方更推崇<code>组合优于继承</code>的设计概念，所以类组件在这方面的优势也在淡出。</li> <li>组件优化上，类组件主要依靠<code>shouldComponentUpdate</code>阻断渲染来提升性能，而函数组件依靠<code>react.memo</code>来缓存渲染结果来提升性能。</li> <li>从上手程度而言，类组件更容易上手，从未来趋势看，由于<code>react hooks</code>的推出，函数组件成了社区未来主推的方案。</li> <li>类组件在未来时间切片与并发模式中，由于生命周期带来的复杂度，并不易于优化。而函数组件本身轻量简单，且<code>hooks</code>的基础上提供了比原来更细粒度的逻辑组织与复用，更能适应react的未来发展。</li></ul> <h3 id="_20、数据管理"><a href="#_20、数据管理" class="header-anchor">#</a> 20、数据管理</h3> <p><strong>React setState调用的原理</strong>
具体的执行过程如下（源码级解析）：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code>” alt=”在这里插入图片描述” data-src=”https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/699f9a657581499cad192a379c19878f~tplv-k3u1fbpfcp-zoom-1.image” data-width=”800″ data-height=”600″ /&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>首先调用了<code>setState</code>入口函数，入口函数在这里就是充当一个分发器的角色，根据入参的不同，将其分发到不同的功能函数中去；</li></ul> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token class-name">ReactComponent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">setState</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">partialState<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>updater<span class="token punctuation">.</span><span class="token function">enqueueSetState</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> partialState<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>updater<span class="token punctuation">.</span><span class="token function">enqueueCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>callback<span class="token punctuation">,</span> <span class="token string">'setState'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ul><li>enqueueSetState方法将薪的<code>state</code>放进组件的状态队列里，并调用<code>enqueueUpdate</code>来处理将要更新的实例对象；</li></ul> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token function-variable function">enqueueSetState</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">publicInstance<span class="token punctuation">,</span> partialState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 根据 this 拿到对应的组件实例</span>
  <span class="token keyword">var</span> internalInstance <span class="token operator">=</span> <span class="token function">getInternalInstanceReadyForUpdate</span><span class="token punctuation">(</span>publicInstance<span class="token punctuation">,</span> <span class="token string">'setState'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 这个 queue 对应的就是一个组件实例的 state 数组</span>
  <span class="token keyword">var</span> queue <span class="token operator">=</span> internalInstance<span class="token punctuation">.</span>_pendingStateQueue <span class="token operator">||</span> <span class="token punctuation">(</span>internalInstance<span class="token punctuation">.</span>_pendingStateQueue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>partialState<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//  enqueueUpdate 用来处理当前的组件实例</span>
  <span class="token function">enqueueUpdate</span><span class="token punctuation">(</span>internalInstance<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><ul><li>在<code>enqueueUpdate</code>方法中引出了一个关键的对象<code>batchingStrategy</code>，该对象所具备的<code>isBatchingUpdates</code>属性直接决定了当下是要走更新流程，还是应该排队等待；如果轮到执行，就调用<code>batchedUpdates</code>方法来直接发起更新流程。由此可以推测，<code>batchingStrategy</code>或许正是<code>React</code>内部专门用于管控批量更新的对象。</li></ul> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">enqueueUpdate</span><span class="token punctuation">(</span><span class="token parameter">component</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">ensureInjected</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 注意这一句是问题的关键，isBatchingUpdates标识着当前是否处于批量创建/更新组件的阶段</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>batchingStrategy<span class="token punctuation">.</span>isBatchingUpdates<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 若当前没有处于批量创建/更新组件的阶段，则立即更新组件</span>
    batchingStrategy<span class="token punctuation">.</span><span class="token function">batchedUpdates</span><span class="token punctuation">(</span>enqueueUpdate<span class="token punctuation">,</span> component<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 否则，先把组件塞入 dirtyComponents 队列里，让它“再等等”</span>
  dirtyComponents<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>component<span class="token punctuation">.</span>_updateBatchNumber <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    component<span class="token punctuation">.</span>_updateBatchNumber <span class="token operator">=</span> updateBatchNumber <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p><strong>注意：</strong> <code>batchingStrategy</code>对象可以理解为“锁管理器”。这里的“锁”，是指<code>React</code>全局唯一的<code>isBatchingUpdates</code>变量，<code>isBatchingUpdates</code>的初始值是<code>false</code>，意味着“当前并未执行任何批量更新操作”。每当<code>React</code>调用<code>batchedUpdate</code>去执行更新动作时，会先把这个锁给“锁上”（设置为<code>true</code>），表明“现在正处于批量更新过程中”，当锁被“锁上”的时候，任何需要更新的组件都只能暂时进入<code>dirtyComponents</code>里排队等候下一次的批量更新，而不能随意“排队”。此处体现的“任务锁”的思想，是<code>React</code>面对大量状态仍然能够用实现有序分批处理的基石。</p> <h2 id="react-setstate-调用之后发生了什么-是同步还是异步"><a href="#react-setstate-调用之后发生了什么-是同步还是异步" class="header-anchor">#</a> React setState 调用之后发生了什么？是同步还是异步？</h2> <p><strong>1、React中setState后发生了什么？</strong>
在代码中调用<code>setState</code>函数之后，<code>React</code>会将传入的参数对象与当前的状态合并，然后触发所为的<code>调和过程</code>。</p> <p>经过调和过程，React会以相对高效的方式根据新的状态构建<code>React</code>元素树并且着手重新渲染整个<code>UI</code>界面。在<code>React</code>得到元素树之后，<code>React</code>会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，<code>React</code>能够相对精确的指导哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。</p> <p>如果在短时间内频繁<code>setState</code>，React会将<code>state</code>的改变压入栈中，在合适的时机，批量更新<code>state</code>和视图，达到提高性能的效果。</p> <p><strong>2、setState是同步还是异步的？</strong></p> <p>假如所有<code>setState</code>是同步的，意味着每执行一次<code>setState</code>(有可能一个同步代码中，多次setState)，都重新<code>vnode diff + dom</code>修改，这对性能来说是极不友好的。如果是异步，则可以把一个同步代码中的多个<code>setState</code>合并成一次组件更新。所以默认是异步的，但是在一些情况下是同步的。</p> <p><code>setState</code>并不是单纯同步/异步的，它的表现会因调用场景的不同而不同。在源码中<code>isBatchingUpdates</code>来判断<code>setState</code>是先存进<code>state</code>队列还是直接更新，如果值为<code>true</code>则执行异步操作，为<code>false</code>则直接更新。</p> <ul><li><strong>同步：</strong> 在React可以控制的地方，就为<code>true</code>，比如在react生命周期事件和合成事件中，都会走合并操作，延迟更新的策略。</li> <li><strong>异步：</strong> 在react无法控制的地方，比如原生事件，具体就是在<code>addEventListener 、setTimeout、setInterval</code>等事件中，就只能同步更新</li></ul> <p>一般认为，做异步设计是为了性能优化、减少渲染次数：</p> <ul><li>setState设计为异步，可以显著的提升性能。如果每次调用<code>setState</code>都进行一次更新，那么就意味着<code>render</code>函数会被频繁调用，界面重新渲染，这样效率是很低的’最好的办法应该是获取到多个更新，之后进行批量更新。</li> <li>如果同步更新了<code>state</code>，但是还没有执行<code>render</code>函数，那么<code>state</code>和<code>props</code>不能保持同步。<code>state</code>和<code>props</code>不能保持一致性，会在开发中产生很多的问题。</li></ul> <p><strong>3、React中的setState批量更新的过程是什么？</strong>
调用<code>setState</code>时，组件的<code>state</code>并不会立即改变，<code>setState</code>只是把要修改的<code>state</code>放入一个队列，React会优化真正的执行时机，并出于性能原因，会将<code>React事件处理程序</code>中的多次React事件处理程序中的多次<code>setState</code>的状态修改合并成一次状态修改。最终更新只产生一次组件及其子组件的重新渲染，这对于大型应用程序中的性能提升至关重要。</p> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  count<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span>    <span class="token comment">//    入队，[count+1的任务]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  count<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span>    <span class="token comment">// 入队，[count+1的任务，count+1的任务]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                                 <span class="token comment">//        合并 state，[count+1的任务]</span>
                                 <span class="token comment">//        执行 count+1的任务</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>需要注意的是，只要同步代码还在执行，“攒起来”这个动作就不会停止。（注：这里之所以多次 +1 最终只有一次生效，是因为在同一个方法中多次 setState 的合并动作不是单纯地将更新累加。比如这里对于相同属性的设置，React 只会为其保留最后一次的更新）。</p> <p><strong>4、React中有使用过getDefaultProps吗？它有什么作用？</strong>
通过实现组件的<code>getDefaultProps</code>，对属性设置默认值（es5的写法）</p> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token keyword">var</span> ShowTitle <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createClass</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function-variable function">getDefaultProps</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span><span class="token punctuation">{</span>
      title <span class="token operator">:</span> <span class="token string">&quot;React&quot;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">render</span> <span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>title<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><strong>5、React中setState的第二个参数作用是什么？</strong> <code>setState</code>的第二个参数是一个可选的回调函数。这个回调函数将在组件重新渲染后执行。等价于在<code>componentDidUpdate</code>生命周期内执行。通常建议使用<code>componentDidUpdate</code>来代替此方式。在这个回调函数中你可以拿到更新后<code>state</code>的值：</p> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    key1<span class="token operator">:</span> newState1<span class="token punctuation">,</span>
    key2<span class="token operator">:</span> newState2<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> callback<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>6、React中的setState和replaceState的区别是什么？</strong></p> <ol><li>setState()用于设置状态对象，其语法如下：</li></ol> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>object nextState<span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token keyword">function</span> callback<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>nextState,将要设置的新状态，改状态会和当前的state合并</li> <li>callback，可选参数，回调函数。该函数会在setState设置成功，且组件重新渲染后调用</li></ul> <p>合并nextState和当前state，并重新渲染组件。setState是React时间处理函数中和请求回调函数中触发Ul更新的主要方法</p> <ol start="2"><li>replaceState方法与setState方法类似，但是方法只会保留<code>nextState</code>中状态，原<code>state</code>不在<code>nextState</code>中的状态都会被删除。</li></ol> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token function">replaceState</span><span class="token punctuation">(</span>object nextState<span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token keyword">function</span> callback<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>nextState，将要设置的新状态，该状态会替换当前的state</li> <li>callback， 可选参数，回调函数。该函数会在replaceState设置爱成功，且组件重新渲染后调用</li></ul> <p><strong>总结：</strong> setState是修改其中的部分状态，相当于<code>Object.assign</code>，只是覆盖，不会减少原来的状态。而<code>replaceState</code>是完全替换原来的状态，相当于赋值，将原来的<code>state</code>替换为另一个对象，如果薪状态属性减少，那么<code>state</code>中就没有这个状态了。</p> <p><strong>7、在React中组件的this.state和setState有什么区别？</strong> <code>this.state</code>通常是用来初始化<code>state</code>的，<code>this.setState</code>是用来修改<code>state</code>值的。如果初始化了<code>state</code>之后再使用<code>this.state</code>，之前的<code>state</code>会被覆盖掉，如果使用<code>this.setState</code>，只会替换掉相应的<code>state</code>值，所以，如果想要修改<code>state</code>的值，就需要使用<code>setState</code>，而不能直接修改<code>state</code>，直接修改<code>state</code>之后页面是不会更新的。</p> <h1 id="路由"><a href="#路由" class="header-anchor">#</a> 路由</h1> <ol><li>react-router的实现原理是什么？
客户端路由实现的思想：</li></ol> <ul><li>基于hash的路由： 通过监听hashchange事件，感知hash的变化</li> <li>改变hash可以直接通过<code>location.hash = xxx</code> <strong>基于H5 history路由：</strong></li> <li>改变url可以通过<code>history.pushState</code>和<code>replaceState</code>等，会将URL压入堆栈，同时能够应用<code>history.go()</code>等API</li> <li>监听url的变化可以通过自定义事件触发实现</li></ul> <p><strong>react-router实现的思想</strong></p> <ul><li>基于history库来实现上述不同的客户端路由实现思想，并且能够保存历史记录等，磨平浏览器差异，上层无感知</li> <li>通过维护的列表，在每次URL发生变化的回收，通过配置的路由路径，匹配到对应的<code>Component</code>，并且<code>render</code></li></ul> <ol start="2"><li>如何配置react-router实现路由切换</li></ol> <ul><li>使用组件，路由匹配时通过比较的path属性和当前地址的pathname来实现的。当一个匹配成功时，它将渲染其内容，当它不匹配时就会渲染null，没有路径时将始终被匹配。</li></ul> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Route</span></span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>/about<span class="token punctuation">'</span></span> <span class="token attr-name">component</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>About<span class="token punctuation">}</span></span><span class="token punctuation">/&gt;</span></span> <span class="token comment">// renders &lt;About/&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Route</span></span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>/contact<span class="token punctuation">'</span></span> <span class="token attr-name">component</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>Contact<span class="token punctuation">}</span></span><span class="token punctuation">/&gt;</span></span> <span class="token comment">// renders null</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Route</span></span> <span class="token attr-name">component</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>Always<span class="token punctuation">}</span></span><span class="token punctuation">/&gt;</span></span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>结合使用 组件和组件用于分组</li></ul> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Switch</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Route</span></span> <span class="token attr-name">exact</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/<span class="token punctuation">&quot;</span></span> <span class="token attr-name">component</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>Home<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Route</span></span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/about<span class="token punctuation">&quot;</span></span> <span class="token attr-name">component</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>About<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Route</span></span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/contact<span class="token punctuation">&quot;</span></span> <span class="token attr-name">component</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>Contact<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Switch</span></span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>不是分组所必须的，但他通常很有用。一个会遍历其所有的子元素，并仅渲染与当前地址匹配的第一个元素</p> <ul><li>使用<code>&lt;Link&gt;&lt;NavLink&gt;、&lt;Redirect&gt; 组件 &lt;Link&gt; 组件来在你的应用程序中创建链接。无论你在何处渲染一个 &lt;Link&gt; ，都会在应用程序的 HTML 中渲染锚（&lt;a&gt;）</code></li></ul> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Link</span></span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Home</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Link</span></span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>是一种特殊类型的，当它的to属性与当前地址匹配时，可以将其定义为“活跃的”</p> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">NavLink</span></span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/react<span class="token punctuation">&quot;</span></span> <span class="token attr-name">activeClassName</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>hurray<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
    React
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">NavLink</span></span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>当我们想强制导航时，可以渲染一个，当一个渲染时，它将使用它的to属性进行定向。</p> <ol start="3"><li>React-Router怎么设置重定向？
使用组件实现路由的重定向：</li></ol> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Switch</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Redirect</span></span> <span class="token attr-name">from</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>/users/:id<span class="token punctuation">'</span></span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>/users/profile/:id<span class="token punctuation">'</span></span><span class="token punctuation">/&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Route</span></span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>/users/profile/:id<span class="token punctuation">'</span></span> <span class="token attr-name">component</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>Profile<span class="token punctuation">}</span></span><span class="token punctuation">/&gt;</span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Switch</span></span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>当请求 /users/:id 被重定向去 '/users/profile/:id'：</p> <ul><li>属性<code>from: string</code>;需要匹配的将要被重定向路径</li> <li>属性<code>to:string</code>;重定向的url字符串</li> <li>属性<code>to: object</code>;重定向的location对象</li> <li>属性<code>push: bool</code>;若为真，重定向操作将会把新地址加入到访问历史记录里面，并且无法回退到当前的页面</li></ul> <ol start="4"><li>react-router 里的 Link 标签和 a 标签的区别
从最终渲染的DOM来看，这两者都是链接，都是标签，区别是：</li></ol> <p>react-router里实现路由跳转的链接，一般配合使用，react-router接管了其默认的链接跳转行为，区别于传统的页面跳转，跳转行为只会触发想匹配的对应的页面内容更新，而不会刷新整个页面，做了三件事：</p> <ul><li>有<code>onclick</code>那就执行onclick</li> <li><code>click</code>的时候阻止<code>a</code>标签默认事件</li> <li>根据跳转href(即是to)，用history (web前端路由两种方式之一，history &amp; hash)跳转，此时只是链接变了，并没有刷新页面而标签就是普通的超链接了，用于从当前页面跳转到href指向的另一 个页面(非锚点情况)。</li></ul> <p><strong>a标签默认事件禁掉之后做了什么才实现了跳转?</strong></p> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token keyword">let</span> domArr <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token operator">...</span>domArr<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    item<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        location<span class="token punctuation">.</span>href <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>href
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ol start="5"><li>React-Router如何获取URL的参数和历史对象？
<strong>1.获取URL的参数</strong></li></ol> <ul><li><strong>get传值</strong>
路由配置还是普通的配置，如： 'admin'传参方式如：'/admin?id=123'。通过<code>this.props.location.search</code>获取url获取到讴歌字符串<code>?id=123</code>可以用<code>url,qs,querystring</code>浏览器提供的api<code>URLSearchParams</code>对象或者自己封装的方法去解析出<code>id</code>的值。</li> <li><strong>动态路由传值</strong>
路由需要配置成动态路由：<code>path='/admin:id'</code>传参方式<code>'/admin/123'</code>通过<code>this.props.match.params.id</code>取得url中的动态路由<code>id</code>部分的值，除此之外还可以通过<code>userParams(hooks)</code>来获取</li> <li><strong>通过query或state传值</strong>
传餐方式：在<code>Link</code>组件的<code>to</code>属性中可以传递对象<code>{pathname:'/admin',query:'111',state:'111'}</code>。通过<code>this.props.location.state</code>或<code>this.props.location.query</code>来获取即可，传递的参数可以使对象、数组等，但是存在缺点就是只要页面刷新，参数就会丢失。</li></ul> <ol><li>获取历史对象</li></ol> <ul><li>如果React =&gt; 16.8时可以使用React Route中提供的Hooks</li></ul> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> useHistory <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react-router-dom'</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> history <span class="token operator">=</span> <span class="token function">useHistory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ol start="2"><li>使用this.props.history获取历史对象</li></ol> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token keyword">let</span> history <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>history<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ol start="6"><li>React-Router 4怎样在路由变化时重新渲染同一个组件？
当路由变化时，即组建的<code>props</code>发生了变化，会调用<code>componentWillReceiveProps</code>等生命周期狗子。那需要做的只是：当路由改变时，根据路由，也去请求数据</li></ol> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token keyword">class</span> <span class="token class-name">NewsList</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  <span class="token function">componentDidMount</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>location<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token parameter">location</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> type <span class="token operator">=</span> location<span class="token punctuation">.</span>pathname<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token string">'top'</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token function">fetchListData</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">componentWillReceiveProps</span><span class="token punctuation">(</span><span class="token parameter">nextProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>nextProps<span class="token punctuation">.</span>location<span class="token punctuation">.</span>pathname <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>location<span class="token punctuation">.</span>pathname<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">fetchData</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">.</span>location<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span> 
  <span class="token punctuation">}</span>
  <span class="token function">render</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>利用<code>componentWillReceiveProps</code>，进行重新<code>render</code>的预处理操作。</p> <ol start="7"><li>React-Router的路由有几种模式？
React-Router支持使用<code>hash</code>(对应HashRouter)和<code>browser</code>(对应BrowserRouter)，两种路由规则，react-router-dom提供了<code>BrowserRouter</code>个<code>HashRouter</code>两个组件来实现应用的UI和URL同步</li></ol> <ul><li>BrowserRouter 创建的 URL 格式：xxx.com/path</li> <li>HashRouter 创建的 URL 格式：xxx.com/#/path</li></ul> <ol><li><code>BrowserRouter</code>它使用HTML5提供的<code>history api</code>pushState、replaceState 和 popstate 事件）来保持UI和URL的同步。由此可以看出<code>BrowserRouter</code>是使用HTML5的<code>history api</code>来控制路由跳转的</li></ol> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">BrowserRouter</span></span>
    <span class="token attr-name">basename</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>string<span class="token punctuation">}</span></span>
    <span class="token attr-name">forceRefresh</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>bool<span class="token punctuation">}</span></span>
    <span class="token attr-name">getUserConfirmation</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>func<span class="token punctuation">}</span></span>
    <span class="token attr-name">keyLength</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>number<span class="token punctuation">}</span></span>
<span class="token punctuation">/&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>属性：</strong></p> <ul><li><code>basename</code>所有路由的基准URL。<code>basename</code>的正确格式是前面有一个前导斜杠，但尾部不能有斜杠</li></ul> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">BrowserRouter</span></span> <span class="token attr-name">basename</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/calendar<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Link</span></span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/today<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">BrowserRouter</span></span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>等同于</p> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/calendar/today<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><code>forceRefresh</code>如果为<code>true</code>，在导航的过程中整个页面将会刷新。一般情况下，只有在不支持HTML5 history API 的浏览器中使用此功能；</li> <li><code>getUserConfirmation</code>用于确认导航的函数，默认使用<code>window.confirm</code>,当从 /a 导航至 /b 时，会使用默认的 confirm 函数弹出一个提示，用户点击确定后才进行导航，否则不做任何处理；</li></ul> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token comment">// 这是默认的确认函数</span>
<span class="token keyword">const</span> <span class="token function-variable function">getConfirmation</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">message<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> allowTransition <span class="token operator">=</span> window<span class="token punctuation">.</span><span class="token function">confirm</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">callback</span><span class="token punctuation">(</span>allowTransition<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">BrowserRouter</span></span> <span class="token attr-name">getUserConfirmation</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>getConfirmation<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ul><li>KeyLength 用来设置 Location.Key 的长度。</li></ul> <ol start="2"><li><code>HashRouter</code>使用URL的hash部分（window.location.hash）来保持UI和URL的同步。由此可以看出<code>HashRouter</code>是通过URL的hash属性来控制路由跳转的</li></ol> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">HashRouter</span></span>
    <span class="token attr-name">basename</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>string<span class="token punctuation">}</span></span>
    <span class="token attr-name">getUserConfirmation</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>func<span class="token punctuation">}</span></span>
    <span class="token attr-name">hashType</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>string<span class="token punctuation">}</span></span>  
<span class="token punctuation">/&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>参数:</p> <ul><li>basename, getUserConfirmation 和 BrowserRouter 功能一样；</li> <li>hashType window.location.hash 使用的 hash 类型，有如下几种：</li> <li>slash – 后面跟一个斜杠，例如 #/ 和 #/sunshine/lollipops；</li> <li>noslash – 后面没有斜杠，例如 # 和 #sunshine/lollipops；</li> <li>hashbang – Google 风格的 ajax crawlable，例如 #!/ 和 #!/sunshine/lollipops。</li></ul> <ol start="8"><li><p>React-Router 4的Switch有什么用？
Switch 通常被用来包裹 Route，用于渲染与路径匹配的第一个子 <Route> 或 <Redirect>，它里面不能放其他元素。</Redirect></Route></p></li> <li><p>如果不加<Switch>:</Switch></p></li></ol> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Route <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react-router-dom'</span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Route</span></span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/<span class="token punctuation">&quot;</span></span> <span class="token attr-name">component</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>Home<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Route</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Route</span></span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/login<span class="token punctuation">&quot;</span></span> <span class="token attr-name">component</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>Login<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Route</span></span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Route组件中的<code>path</code>属性用于匹配路径，因为需要匹配<code>/</code>到<code>Home</code>，匹配<code>/login</code>到<code>Login</code>，所以需要两个Route。但是不能这么写。这样写的话，当URL的<code>path</code>为<code>/login</code>时，<code>&lt;Route path=&quot;/&quot; /&gt;</code>和<code>&lt;Route path=&quot;/login&quot; /&gt;</code>都会被匹配，因此页面会展示<code>Home</code>和<code>Login</code>两个组件。这时就需要借助<code>&lt;Switch&gt;</code>来做到只显示一个匹配组件</p> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Switch<span class="token punctuation">,</span> Route<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react-router-dom'</span>
    
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Switch</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Route</span></span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/<span class="token punctuation">&quot;</span></span> <span class="token attr-name">component</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>Home<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Route</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Route</span></span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/login<span class="token punctuation">&quot;</span></span> <span class="token attr-name">component</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>Login<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Route</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Switch</span></span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>此时，再访问<code>/login</code>路径时，却只显示了<code>Home</code>组件。这就用到了<code>exact</code>属性，它的作用就是精确匹配路径，经常与<code>&lt;Switch&gt;</code>联合使用，只有当URL和该<code>&lt;Route&gt;</code>的<code>path</code>属性完全一致的情况下才能匹配上：</p> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Switch<span class="token punctuation">,</span> Route<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react-router-dom'</span>
   
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Switch</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
   </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Route</span></span> <span class="token attr-name">exact</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/<span class="token punctuation">&quot;</span></span> <span class="token attr-name">component</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>Home<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Route</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
   </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Route</span></span> <span class="token attr-name">exact</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/login<span class="token punctuation">&quot;</span></span> <span class="token attr-name">component</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>Login<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Route</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Switch</span></span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>转载自：https://juejin.cn/post/6941546135827775525</p></div></section> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最后更新时间: </span> <span class="time">2021-06-27 23:18:34</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/blogs/category/react/configReactProduct.html" class="prev">
            配置eslint和less module
          </a></span> <span class="next"><a href="/blogs/category/react/reactHooks.html">
            react-hooks
          </a></span></p></div> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:0;" data-v-70334359></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><div class="kanbanniang" data-v-5775ee02><div class="banniang-container" style="display:;" data-v-5775ee02><div class="messageBox" style="right:68px;bottom:190px;display:none;" data-v-5775ee02>
      欢迎来到
    </div> <div class="operation" style="right:90px;bottom:40px;display:;" data-v-5775ee02><i class="kbnfont kbn-ban-home ban-home" data-v-5775ee02></i> <i class="kbnfont kbn-ban-message message" data-v-5775ee02></i> <i class="kbnfont kbn-ban-close close" data-v-5775ee02></i> <a target="_blank" href="https://vuepress-theme-reco.recoluan.com/views/plugins/kanbanniang.html" data-v-5775ee02><i class="kbnfont kbn-ban-info info" data-v-5775ee02></i></a> <i class="kbnfont kbn-ban-theme skin" style="display:none;" data-v-5775ee02></i></div> <canvas id="banniang" width="240" height="352" class="live2d" style="right:90px;bottom:-20px;opacity:0.9;" data-v-5775ee02></canvas></div> <div class="showBanNiang" style="display:none;" data-v-5775ee02>
    看板娘
  </div></div><canvas id="vuepress-canvas-cursor"></canvas><div></div><div class="Sakura" data-v-017cf06a><canvas id="canvas_sakura" style="z-index:-1;" data-v-017cf06a></canvas></div></div></div>
    <script src="/assets/js/app.c57aec4d.js" defer></script><script src="/assets/js/4.b5d4bb75.js" defer></script><script src="/assets/js/1.38fca83b.js" defer></script><script src="/assets/js/14.6044522d.js" defer></script>
  </body>
</html>
