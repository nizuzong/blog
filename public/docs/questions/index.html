<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>面试题 | 林深的博客</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="林深的博客">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.8f0fc25a.css" as="style"><link rel="preload" href="/assets/js/app.c16eda41.js" as="script"><link rel="preload" href="/assets/js/4.b5d4bb75.js" as="script"><link rel="preload" href="/assets/js/1.38fca83b.js" as="script"><link rel="preload" href="/assets/js/27.a168590d.js" as="script"><link rel="prefetch" href="/assets/js/10.ab5c93b4.js"><link rel="prefetch" href="/assets/js/11.b0fadce1.js"><link rel="prefetch" href="/assets/js/12.5bd94ac4.js"><link rel="prefetch" href="/assets/js/13.e04e603e.js"><link rel="prefetch" href="/assets/js/14.7954a1dc.js"><link rel="prefetch" href="/assets/js/15.5b1c9a9a.js"><link rel="prefetch" href="/assets/js/16.54111c72.js"><link rel="prefetch" href="/assets/js/17.bd6889cb.js"><link rel="prefetch" href="/assets/js/18.2732f661.js"><link rel="prefetch" href="/assets/js/19.8e347516.js"><link rel="prefetch" href="/assets/js/20.aa569e08.js"><link rel="prefetch" href="/assets/js/21.3a4371ed.js"><link rel="prefetch" href="/assets/js/22.690ab443.js"><link rel="prefetch" href="/assets/js/23.ff404aa5.js"><link rel="prefetch" href="/assets/js/24.09cbb649.js"><link rel="prefetch" href="/assets/js/25.aaa3b440.js"><link rel="prefetch" href="/assets/js/26.3d6ba757.js"><link rel="prefetch" href="/assets/js/28.fea23751.js"><link rel="prefetch" href="/assets/js/5.b58a7347.js"><link rel="prefetch" href="/assets/js/6.65f13f2f.js"><link rel="prefetch" href="/assets/js/7.6602d270.js"><link rel="prefetch" href="/assets/js/8.2d0891a7.js"><link rel="prefetch" href="/assets/js/9.0f2eba27.js"><link rel="prefetch" href="/assets/js/vendors~flowchart.10d5f383.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8f0fc25a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-1156296a><div data-v-1156296a><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-1156296a data-v-1156296a><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-4e82dffc data-v-1156296a data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>林深的博客</h3> <p class="description" data-v-4e82dffc data-v-4e82dffc>林深的博客</p> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><span data-v-4e82dffc>林深</span>
            
          <!---->
          2021
        </a></span></div></div> <div class="hide" data-v-1156296a><header class="navbar" data-v-1156296a><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.png" alt="林深的博客" class="logo"> <span class="site-name">林深的博客</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/react/" class="nav-link"><i class="undefined"></i>
  react
</a></li><li class="dropdown-item"><!----> <a href="/categories/typeScript/" class="nav-link"><i class="undefined"></i>
  typeScript
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  文档历史
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      链接
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-1156296a></div> <aside class="sidebar" data-v-1156296a><div class="personal-info-wrapper" data-v-828910c6 data-v-1156296a><img src="/avatar.jpeg" alt="author-avatar" class="personal-img" data-v-828910c6> <h3 class="name" data-v-828910c6>
    林深
  </h3> <div class="num" data-v-828910c6><div data-v-828910c6><h3 data-v-828910c6>17</h3> <h6 data-v-828910c6>Articles</h6></div> <div data-v-828910c6><h3 data-v-828910c6>3</h3> <h6 data-v-828910c6>Tags</h6></div></div> <ul class="social-links" data-v-828910c6></ul> <hr data-v-828910c6></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/react/" class="nav-link"><i class="undefined"></i>
  react
</a></li><li class="dropdown-item"><!----> <a href="/categories/typeScript/" class="nav-link"><i class="undefined"></i>
  typeScript
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  文档历史
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      链接
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-4e82dffc data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>面试题</h3> <!----> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><span data-v-4e82dffc>林深</span>
            
          <!---->
          2021
        </a></span></div></div> <div data-v-1156296a><main class="page"><section><div class="page-title"><h1 class="title">面试题</h1> <div data-v-1ff7123e><i class="iconfont reco-account" data-v-1ff7123e><span data-v-1ff7123e>林深</span></i> <i class="iconfont reco-date" data-v-1ff7123e><span data-v-1ff7123e>6/5/2021</span></i> <!----> <!----></div></div> <div class="theme-reco-content content__default"><h1 id="react篇"><a href="#react篇" class="header-anchor">#</a> react篇</h1> <h2 id="组件基础"><a href="#组件基础" class="header-anchor">#</a> 组件基础</h2> <h3 id="_1、react事件绑定原理"><a href="#_1、react事件绑定原理" class="header-anchor">#</a> 1、react事件绑定原理</h3> <div class="language-typescript jsx line-numbers-mode"><pre class="language-typescript"><code><span class="token operator">&lt;</span>div onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleClick<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>react 并不是将<code>click</code>事件绑定到了<code>div</code>真实的<code>DOM</code>上，而是在<code>document</code>处监听了所有的事件，当事件发生并且冒泡到<code>document</code>处的时候，
react 将事件内容封装并交由真正的处理函数执行。这样的方式不仅仅减少了内存的消耗，还能在组件挂载销毁时统一订阅和移除事件。</p> <p>还有， 冒泡到<code>document</code>上的事件也不是原生的浏览器事件，而是由react自己合成的事件，所以不想要事件冒泡的话应该调用<code>event.preventDefault()</code>方法，而
不是调用<code>event.stopProppagation()</code>方法</p> <h3 id="_2、react的事件和普通的html事件有什么不同"><a href="#_2、react的事件和普通的html事件有什么不同" class="header-anchor">#</a> 2、React的事件和普通的HTML事件有什么不同？</h3> <h4 id="区别"><a href="#区别" class="header-anchor">#</a> 区别：</h4> <ol><li>对于事件名称的命名方式，原生事件为全小写，而react 事件采用小驼峰</li> <li>对于事件函数处理语法，原生事件为字符串，react 事件为函数</li> <li>react 事件不能采取<code>return false</code>的方法来阻止浏览器的默认行为，而必须要地明确地调用<code>preventDefault()</code>来阻止默认行为</li></ol> <h3 id="合成事件是-react-模拟原生-dom-事件所有能力的一个事件对象-优点"><a href="#合成事件是-react-模拟原生-dom-事件所有能力的一个事件对象-优点" class="header-anchor">#</a> 合成事件是 react 模拟原生 DOM 事件所有能力的一个事件对象 优点</h3> <ol><li>兼容所有的浏览器，更好的跨平台</li> <li>将事件统一存放在一个数组，避免频繁的新增和删除（垃圾回收）</li> <li>方便react统一管理和事件机制</li></ol> <h3 id="_3、-react-组件中怎么做事件代理-它的原理是什么"><a href="#_3、-react-组件中怎么做事件代理-它的原理是什么" class="header-anchor">#</a> 3、 React 组件中怎么做事件代理？它的原理是什么？</h3> <p>react基于<code>Virtual DOM</code>实现一个<code>事件合成层</code>，定义的事件处理器会接收到一个合成事件对象的实例。它符合W3CW标准，且与原生浏览器事件有相同的接口。
支持冒泡事件，所有的事件都自动绑定在最外层。</p> <h4 id="在react底层-主要对合成事件做了-事件委派和自动绑定。"><a href="#在react底层-主要对合成事件做了-事件委派和自动绑定。" class="header-anchor">#</a> 在React底层，主要对合成事件做了：事件委派和自动绑定。</h4> <ul><li><strong>事件委派：</strong> react会把所有事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上w维持了一个映射来保存s所有组件内部事件监听和处理函数</li> <li><strong>自动绑定：</strong> react组件中，每个方法的上下文都对指向该组件的实例，即自动绑定 <strong>this</strong> 为当前组件</li></ul> <h3 id="_4、react-高阶组件、render-props、hooks-有什么区别-为什么要不断迭代"><a href="#_4、react-高阶组件、render-props、hooks-有什么区别-为什么要不断迭代" class="header-anchor">#</a> 4、React 高阶组件、Render props、hooks 有什么区别，为什么要不断迭代</h3> <p><strong>这三个是目前react解决代码复用的主要方式。</strong></p> <ul><li>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。具体而言，高阶组件是参数为组件，返回值为新组件的函数。</li> <li>render props是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术，更具体的说，render prop 是一个用于告知组件需要渲染什么内容的函数 prop。</li> <li>通常，render props 和高阶组件只渲染一个子节点。让 Hook 来服务这个使用场景更加简单。这两种模式仍有用武之地，（例如，一个虚拟滚动条组件或许会有一个 <code>renderltem</code> 属性，或是一个可见的容器组件或许会有它自己的 DOM 结构）。但在大部分场景下，<code>Hook</code> 足够了，并且能够帮助减少嵌套。</li></ul> <p><strong>HOC 官方解释∶</strong></p> <div class="language- extra-class"><pre><code>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。
HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。
</code></pre></div><p><strong>简单的来说，HOC是一种组件的设计模式，HOC接受一个组件和额外的参数（如果需要），返回一个新的组件。HOC 是纯函数，没有副作用。</strong></p> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token comment">// hoc的定义</span>
<span class="token keyword">function</span> <span class="token function">withSubscription</span><span class="token punctuation">(</span><span class="token parameter">WrappedComponent<span class="token punctuation">,</span> selectData</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> React<span class="token punctuation">.</span>Component <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
        data<span class="token operator">:</span> <span class="token function">selectData</span><span class="token punctuation">(</span>DataSource<span class="token punctuation">,</span> props<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 一些通用的逻辑处理</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// ... 并使用新数据渲染被包装的组件!</span>
      <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">WrappedComponent</span></span> <span class="token attr-name">data</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>data<span class="token punctuation">}</span></span> <span class="token spread"><span class="token punctuation">{</span><span class="token punctuation">...</span><span class="token attr-value">this</span><span class="token punctuation">.</span><span class="token attr-value">props</span><span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 使用</span>
<span class="token keyword">const</span> BlogPostWithSubscription <span class="token operator">=</span> <span class="token function">withSubscription</span><span class="token punctuation">(</span>BlogPost<span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token parameter">DataSource<span class="token punctuation">,</span> props</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> DataSource<span class="token punctuation">.</span><span class="token function">getBlogPost</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><h4 id="hoc的优缺点∶"><a href="#hoc的优缺点∶" class="header-anchor">#</a> hoc的优缺点∶</h4> <ul><li>优点∶ 逻辑服用、不影响被包裹组件的内部逻辑</li> <li>缺点：hoc传递给被包裹组件的props容易和被包裹后的组件重名，进而被覆盖</li></ul> <h4 id="render-props-官方解释∶"><a href="#render-props-官方解释∶" class="header-anchor">#</a> Render props 官方解释∶</h4> <div class="language- extra-class"><pre><code>”render prop”是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术
</code></pre></div><p>具有<code>render prop</code> 的组件接受一个返回 <strong>react</strong> 元素的函数，将render的渲染逻辑注入到组件内部，在这里 <strong>render</strong> 的命名
可以使其他有效的标识符</p> <div class="language-typescript jsx line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// DataProvider组件内部的渲染逻辑如下</span>
<span class="token keyword">class</span> <span class="token class-name">DataProvider</span> <span class="token keyword">extends</span> <span class="token class-name">React</span><span class="token punctuation">.</span>Components <span class="token punctuation">{</span>
     state <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">'Tom'</span>
  <span class="token punctuation">}</span>

    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
        <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
          <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>共享数据组件自己内部的渲染逻辑<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
          <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">)</span> <span class="token punctuation">}</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 调用方式</span>
<span class="token operator">&lt;</span>DataProvider render<span class="token operator">=</span><span class="token punctuation">{</span>data <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>
  <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>Hello <span class="token punctuation">{</span>data<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><h4 id="由此可以看到-render-props的优缺点也很明显∶"><a href="#由此可以看到-render-props的优缺点也很明显∶" class="header-anchor">#</a> 由此可以看到，render props的优缺点也很明显∶</h4> <ul><li>优点：数据共享、代码复用，将组件内的state作为props传递给调用者，将渲染逻辑交给调用者。</li> <li>缺点：无法在 return 语句外访问数据、嵌套写法不够优雅</li></ul> <h4 id="hooks-官方解释∶"><a href="#hooks-官方解释∶" class="header-anchor">#</a> Hooks 官方解释∶</h4> <div class="language- extra-class"><pre><code>Hook是 React 16.8 的新增特性。
它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。
通过自定义hook，可以复用代码逻辑。
</code></pre></div><div class="language-typescript jsx line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// 自定义一个获取订阅数据的hook</span>
<span class="token keyword">function</span> <span class="token function">useSubscription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> data <span class="token operator">=</span> DataSource<span class="token punctuation">.</span><span class="token function">getComments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span>data<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// </span>
<span class="token keyword">function</span> <span class="token function">CommentList</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span>data<span class="token punctuation">}</span> <span class="token operator">=</span> props<span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>subData<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useSubscription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">...</span>
<span class="token punctuation">}</span>
<span class="token comment">// 使用</span>
<span class="token operator">&lt;</span>CommentList data<span class="token operator">=</span><span class="token string">'hello'</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>以上可以看出，hook解决了hoc的prop覆盖的问题，同时使用的方式解决了render props的嵌套地狱的问题。hook的优点如下∶</p> <ul><li>使用直观</li> <li>解决hoc的prop 重名问题</li> <li>解决render props 因共享数据 而出现嵌套地狱的问题</li> <li>能在return之外使用数据的问题</li></ul> <p>需要注意的是∶hook只能在组件顶层使用，不可在分支语句中使用。</p> <p><strong>总结：</strong> Hoc、render props和hook都是为了解决代码复用的问题，但是hoc和render props都有特定的使用场景和明显的缺点。hook是react16.8更新的新的API，让组件逻辑复用更简洁明了，同时也解决了hoc和render props的一些缺点。</p> <h3 id="_5、对react-fiber的理解-它解决了什么问题"><a href="#_5、对react-fiber的理解-它解决了什么问题" class="header-anchor">#</a> 5、对React-Fiber的理解，它解决了什么问题？</h3> <p>React V15 在渲染时，会递归比对 VirtualDOM 树，找出需要变动的节点，然后同步更新它们， 一气呵成。这个过程期间， React 会占据浏览器资源，这会导致用户触发的事件得不到响应，并且会导致掉帧，
<strong>导致用户感觉到卡顿</strong></p> <p>为了给用户制造一种应用很快的“假象”，不能让一个任务长期霸占着资源。 可以将浏览器的渲染、布局、绘制、资源加载(例如 HTML 解析)、事件响应、脚本执行视作操作系统的“进程”，需要通过某些调度策略合理地分配 CPU 资源，从而提高浏览器的用户响应速率, 同时兼顾任务执行效率。</p> <p>所以 React 通过Fiber 架构，让这个执行过程变成可被中断。“适时”地让出 CPU 执行权，除了可以让浏览器及时地响应用户的交互，还有其他好处:</p> <ul><li>分批延时对DOM进行操作，避免一次性操作大量 DOM 节点，可以得到更好的用户体验；</li> <li>给浏览器一点喘息的机会，它会对代码进行编译优化（JIT）及进行热代码优化，或者对 reflow 进行修正。__核心思想：__Fiber 也称协程、或者纤程。它和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制。
让出 CPU 的执行权，让 CPU 能在这段时间执行其他的操作。渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染。</li></ul> <h3 id="_6、react-component-和-react-purecomponent-的区别"><a href="#_6、react-component-和-react-purecomponent-的区别" class="header-anchor">#</a> 6、React.Component 和 React.PureComponent 的区别？</h3> <p>pureComponent表示一个纯组件，可以用来优化react组件，减少render函数执行的次数，从而提高组件的性能</p> <p>在react中，当<code>props</code>或<code>state</code>发生变化时，可以通过在<code>shouldComponentUpdate</code>生命周期函数中执行<code>return false</code>来阻止页面的更新，从而减少不必要的render执行。React.PureComponent会自动执行 shouldComponentUpdate。</p> <p>不过，pureComponent中的<code>shouldComponentUpdate()</code>进行的是 <strong>浅比较</strong> ，也就是说如果是 <strong>引用类型数据</strong> ,只会比较不是同一个地址，而不会比较这个地址里面的数据是否一致。浅比较会忽略属性或状态突变情况。其实也就是数据引用指针没有变化。而数据发生改变的时候render是不会执行的。
如果需要重新渲染那么就需要重新开辟空间引用数据。PureComponent一般会用在一些纯展示组件上。</p> <h4 id="使用purecomponent的好处"><a href="#使用purecomponent的好处" class="header-anchor">#</a> 使用pureComponent的好处：</h4> <p>当组件更新时，如果组件的props或state没有改变，render函数就不会触发。省去虚拟dom的生成和对比过程，达到提升性能的目的。这是因为react自动做了一层浅比较。</p> <h3 id="_7、component-element-instance-之间有什么区别和联系"><a href="#_7、component-element-instance-之间有什么区别和联系" class="header-anchor">#</a> 7、Component, Element, Instance 之间有什么区别和联系？</h3> <p><strong>元素:</strong> 一个元素element是一个普通对象，描述了对于一个DOM节点或者其他组件component,你想让他在屏幕中呈现什么样子。素element可以在它的属性props中包含其他元素(译注:用于形成元素树)。创建一个React元素element成本很低。元素element创建之后是不可变的。</p> <p><strong>组件：</strong> 一个组件component可以通过多种方式声明。可以是带有一个render()方法的类，简单点也可以定义为一个函数。这两种情况下，它都把属性props作为输入，把返回的一棵元素树作为输出。</p> <p><strong>实例：</strong> 一个实例instance是你在所写的组件类<code>component class</code>中使用关键字this所指向的东西(译注:组件实例)。它用来存储本地状态和响应生命周期事件很有用。</p> <p>函数试组件根本没有instance实例，类组件有实例，但是永远也不要直接创建一个组件的实例，因为react已经帮我们做了这些。</p> <h3 id="_8、对componentwillreceiveprops-的理解"><a href="#_8、对componentwillreceiveprops-的理解" class="header-anchor">#</a> 8、对componentWillReceiveProps 的理解</h3> <p>该生命周期函数只有在props发生变化时执行，初始化render时不执行，在这个回调函数里面，你可以根据属性的变化，通过调用<code>this.setState()</code>来更新你的组件状态，旧的属性还是可以通过<code>this.props</code>来获取，这里调用更新状态是安全的。并不会触发额外的render调用。</p> <p><strong>使用好处：</strong> 在这个生命周期中，可以在子组件的render函数执行前获取新的props，从而更新子组件自己的state。可以将数据请求放在这里进行执行，需要传的参数则从<code>componentWillReceiveProps(nextProps)</code>中获取。而不必将所有的请求都放在父组件中。于是该请求只会在该组件渲染时才会发出，从而减轻请求负担。<code>componentWillReceiveProps(nextProps)</code>在初始化render的时候不会执行，它会在component接收到新的props（状态）时被触发，一遍用于父组件状态更新时子组件重新渲染。</p> <h3 id="_9、哪些方法会触发-react-重新渲染-重新渲染-render-会做些什么"><a href="#_9、哪些方法会触发-react-重新渲染-重新渲染-render-会做些什么" class="header-anchor">#</a> 9、哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？</h3> <p><strong>1、哪些方法会触发 react 重新渲染?</strong></p> <ul><li>setState()方法被调用</li></ul> <p>setState是react中最常用的命令，通常情况下，执行setState会触发render。但是这里有个点需要注意一下，执行setState的时候一定会重新渲染吗？答案是不一定，当setState传入null的时候，并不会触发render。</p> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  state <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token operator">:</span> <span class="token number">1</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;render&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">React.Fragement</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>a<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span>
          <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这里并没有改变 a 的值</span>
          <span class="token punctuation">}</span><span class="token punctuation">}</span></span>
        <span class="token punctuation">&gt;</span></span><span class="token plain-text">
          Click me
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">setState null</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Child</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">React.Fragement</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><ul><li>父组件重新渲染
只有父组件重新渲染了，即使传入子组件的props未发生变化，那么子组件也会重新渲染，进而触发render</li></ul> <p><strong>2、重新渲染render会做些什么？</strong></p> <ul><li>会对新旧Vnode进行对比，也就是我们所说的diff算法</li> <li>对新旧两颗树进行一个深度优先遍历，这样每一个节点都会有一个标记，在到深度遍历的时候，每遍历到一个节点。就把该节点和新的节点树进行对比，如果有差异就放到一个对象里面</li> <li>遍历差异对象，根据差异的类型，根据应对规则更新Vnode</li></ul> <p>react的处理Render的基本思维模式是每次一有变动就会去重新渲染整个应用。在虚拟dom没出现之前，最简单的方法就是直接调用innerHTML。虚拟dom厉害的地方并不是说他比直接操作dom快，而是说不管数据怎么变，都会尽量以最小的代价去更新dom，react将render函数返回的虚拟dom树与老的进行比较，从而确定dom要不要更新、怎么更新。当DOM树很大时，遍历两棵树进行各种比对是相当耗性能的，特别是在顶层setState一个微小的修改，默认回去遍历整颗树。尽管react使用高度优化的diff算法，但是这个过程仍会损耗性能。</p> <h3 id="_10、react如何判断什么时候重新渲染组件"><a href="#_10、react如何判断什么时候重新渲染组件" class="header-anchor">#</a> 10、React如何判断什么时候重新渲染组件？</h3> <p>组件状态的改变可以因为props的改变，或者直接通过setState方法改变。组件获得新的状态然后React决定是否应该重新渲染组件。只要组件的State发生变化，react就会对组件进行重新渲染。这是因为react中的<code>shouldComponentUpdate</code>方法默认返回 <code>true</code>，这就是导致每次更新都重新渲染的原因。</p> <p>当react将要渲染组件时会执行<code>shouldComponentUpdate</code>方法来看它是否返回true（组件应该更新，也就是重新渲染）。所以需要重写<code>shouldComponentUpdate</code>方法让它根据情况返回true或者false来告诉React什么时候重新渲染什么时候跳过重新渲染。</p> <h3 id="_11、对有状态组件和无状态组件的理解及使用场景"><a href="#_11、对有状态组件和无状态组件的理解及使用场景" class="header-anchor">#</a> 11、对有状态组件和无状态组件的理解及使用场景</h3> <p><strong>有状态组件 特点：</strong></p> <ul><li>是一个类组件、有继承、可以使用this</li> <li>可以使用react的生命周期</li> <li>使用较多，容易频繁触发生命周期钩子函数，影响性能</li> <li>内部使用state,维护自身状态的变化，有状态组件根据外部组件传入的props和自身的State进行渲染</li></ul> <p><strong>使用场景</strong></p> <ul><li>需要使用到状态的</li> <li>需要使用状态操作组件的（无状态组件的也可以实现新版本react hooks也可以实现）</li></ul> <p><strong>总结：</strong>
类组件可以维护自身的状态变量，即组件的state,类组件还有不同的生命周期方法，可以让开发者能够在组件的不同阶段（挂载、更新、卸载），对组件做更多的控制。类组件既可以充当无状态组件，也可以充当有状态组件。当一个类组件不需要管理自身状态时，也可以被称为无状态组件。</p> <p><strong>无状态组件  特点</strong></p> <ul><li>不依赖自身的状态state</li> <li>可以使类组件或者函数组件</li> <li>可以完全避免使用<code>this</code>关键字（由于使用的是箭头函数无需绑定）</li> <li>有更高的性能。当不需要使用生命周期钩子时，应该首先使用无状态组件</li> <li>组件内部不维护state，只根据外部组件传入的props进行渲染的组件，当props改变时，组件重新渲染</li></ul> <p><strong>使用场景</strong></p> <ul><li>组件不需要管理state，纯展示</li></ul> <p><strong>有点</strong></p> <ul><li>简化代码，专注render</li> <li>组件不需要被实例化，无生命周期，提高性能。渲染只取决于属性，无副作用</li> <li>视图和数据的解耦分离</li></ul> <p><strong>缺点</strong></p> <ul><li>无法使用ref和生命周期方法</li> <li>无法控制组件的重渲染，因为无法使用<code>shouldComponentUpdate</code>方法，当组件接收到的属性时则会冲渲染</li></ul> <p><strong>总结：</strong>
组件内部状态且与外部无关的组件，可以考虑用五状态组件，这样状态数就不会过于复杂，易于理解和管理。当一个组件不需要管理自身状态时，也就是无状态组件，应该优先设计为函数组件。</p> <h3 id="_12、对react中fragment的理解-它的使用场景是什么"><a href="#_12、对react中fragment的理解-它的使用场景是什么" class="header-anchor">#</a> 12、对React中Fragment的理解，它的使用场景是什么？</h3> <p>在react中，组件返回的元素只能有一个根元素。为了不添加多余的dom节点，我们可以使用<code>Fragment</code>标签来包裹所有的元素，Fragment标签不会渲染出任何元素。</p> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> Component<span class="token punctuation">,</span> Fragment <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span>

<span class="token comment">// 一般形式</span>
<span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">React.Fragment</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ChildA</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ChildB</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ChildC</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">React.Fragment</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 也可以写成以下形式</span>
<span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ChildA</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ChildB</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ChildC</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><h3 id="_13、在react中如何避免不必要的render"><a href="#_13、在react中如何避免不必要的render" class="header-anchor">#</a> 13、在React中如何避免不必要的render？</h3> <p>React基于虚拟DOM和高效diff算法的完美配合，实现了对DOM最小粒度的更新。大多情况下，react对DOM的渲染效率足以业务日常。但在个别复杂业务场景下，性能问题依然存在。此时需要采取一些措施来提升运行性能，其很重要的一个方向就是尽可能的避免<code>render</code></p> <ul><li>shouldComponentUpdate和PureComponent</li></ul> <p>在react类组件中，可以利用<code>shouldComponentUpdate</code>或者<code>pureComponent</code>来减少因父组件更新而触发子组件render，从而达到目的。<code>shouldComponentUpdate</code>来决定是否组件是否重新渲染，如果不希望组件重新渲染，返回<code>false</code>即可。</p> <ul><li>利用高阶组件</li></ul> <p>在函数组件中，并没有 <code>shouldComponentUpdate</code>这个生命周期，可以利用高阶组件，封装一个类似<code>PureComponet</code>的功能</p> <ul><li>使用React.memo</li></ul> <p>React.mome是react<code>16.0</code>新的一个API，用来缓存组件的渲染，避免不必要的更新，其实也会死你一个高阶组件，与<code>PureComponent</code>十分类似，但不同的是<code>React.memo</code>只能用于函数组件。</p> <h3 id="_14、对-react-context-的理解"><a href="#_14、对-react-context-的理解" class="header-anchor">#</a> 14、对 React context 的理解</h3> <p>在React中， 数据传递一般使用props传递数据，维持单项数据流，这样可以让组件之间的关系变得简单可预测，但是单向数据流在某些场景中并不适用。单纯一对的父子组件传递并无问题，但要是组件之间层层依赖深入，<code>props</code>就需要层层传递，显然这样做太繁琐了。</p> <p><code>Context</code>提供了一种在组件之间共享此类值得方法，而不必显式的通过组件树的逐层传递 <code>props</code></p> <p>可以把<code>context</code>当做是特定一个组件数内共享的<code>store</code>，用来做数据传递。<code>简单的说就是，当年你不想在组件树中通过逐层传递props或者state的方式来传递数据时，可以使用Context来实现跨层级的组件数据传递。</code></p> <p>js的代码在执行期间，会创建一个相应的作用域链，这个作用域链记录这运行时js代码块执行期间所能访问的活动对象，包括变量和函数，js程序通过作用域链访问到代码块内部或者外部的变量和函数</p> <p>假如以js的作用域链作为类比，react组件提供的context对象其实就是好比一个提供给子组件访问的作用域，而Context对象的属性可以看成作用域上的活动对象。由于组件的context由父节点链上所有组件通过<code>getChildContext（）</code>返回的context对象组合而成，所以组件通过context是可以访问到其父组件链上所有节点组件提供的context的属性。</p> <h3 id="_15、为什么react并不推荐优先考虑使用context"><a href="#_15、为什么react并不推荐优先考虑使用context" class="header-anchor">#</a> 15、为什么React并不推荐优先考虑使用Context？</h3> <ul><li><p>context目前还处于实验阶段，可能会在后面发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来的影响和麻烦，不建议在app中使用context。</p></li> <li><p>尽管不建议在app中使用context，但是独有组件而言，由于影响范围小于app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用context；</p></li> <li><p>对于组件之间的数据通信或者状态管理，有效使用props或者State解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳方案的时候，考虑context</p></li> <li><p>context的更新需要通过<code>setState()</code>触发，但是这并不是可靠的，context支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如<code>shouldComponentUpdate()</code>返回<code>false</code>那么不能保证context的更新一定可以使用context的子组件，因此，context的可靠性需要关注</p></li></ul> <h3 id="_16、react中refs的作用是什么-有哪些应用场景"><a href="#_16、react中refs的作用是什么-有哪些应用场景" class="header-anchor">#</a> 16、React中refs的作用是什么？有哪些应用场景？</h3> <p>Refs提供了一种方式，用于访问在 <code>render</code>方法中创建的<code>react</code>元素或<code>DOM</code>节点，refs应该谨慎使用，如下场景使用refs比较适合：</p> <ul><li>处理焦点、文本选择或者媒体的控制</li> <li>触发必要的动画</li> <li>集成第三方DOM库</li></ul> <p><strong>注意：</strong></p> <ul><li>不应该国度的使用refs</li> <li>ref的返回值取决于节点的类型</li></ul> <ol><li>当ref属性被用于一个普通的<code>HTML</code>元素时，<code>react.createRef()</code>将接收底层<code>DOM</code>元素作为它的<code>current</code>属性以创建ref。</li> <li>当ref属性被用于一个自定义的类组件时，ref对象将接收该组件已挂载的实例作为它的<code>current</code></li></ol> <ul><li>当在父组件中需要访问子组件中的ref时可使用传递refs或回调refs。</li></ul> <h3 id="_17、react组件的构造函数有什么作用-它是必须的吗"><a href="#_17、react组件的构造函数有什么作用-它是必须的吗" class="header-anchor">#</a> 17、React组件的构造函数有什么作用？它是必须的吗？</h3> <p>构造函数主要用于两个目的：</p> <ul><li>通过将对象分配给<code>this.state</code>来初始化本地状态</li> <li>将事件处理程序方法绑定到实例上</li></ul> <p>所以，当在React class中需要设置state的初始值或者绑定事件时，需要加上构造函数，官方Demo:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">LikeButton</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
      liked<span class="token operator">:</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>handleClick <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleClick</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>liked<span class="token operator">:</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>liked<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> text <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>liked <span class="token operator">?</span> <span class="token string">'liked'</span> <span class="token operator">:</span> <span class="token string">'haven\'t liked'</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleClick<span class="token punctuation">}</span><span class="token operator">&gt;</span>
        You <span class="token punctuation">{</span>text<span class="token punctuation">}</span> <span class="token keyword">this</span><span class="token punctuation">.</span> Click to toggle<span class="token punctuation">.</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>
  <span class="token operator">&lt;</span>LikeButton <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
  document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'example'</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>构造函数用来新建父类的<code>this</code>对象；子类必须在<code>constructor</code>方法中调用<code>super</code>方法；否则新建实例时会报错；因为子类没有自己的<code>this</code>对象，而是继承父类的<code>this</code>对象，然后对其进行加工。如果不调用<code>super</code>方法；子类就得不到<code>this</code>对象。</p> <p><strong>注意：</strong></p> <ul><li>constructor() 必须配上super()，如果要在constructor内部使用<code>this.props</code>就要传入<code>props</code>，否则不用</li> <li>js中的<code>bind</code>每次都会返回一个新的函数，为了性能等考虑，尽量在<code>constructor</code>中绑定事件</li></ul></div></section> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最后更新时间: </span> <span class="time">6/5/2021, 12:54:34 AM</span></div></footer> <!----> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-70334359><li class="level-2" data-v-70334359><a href="/docs/questions/#组件基础" class="sidebar-link reco-side-组件基础" data-v-70334359>组件基础</a></li><li class="level-3" data-v-70334359><a href="/docs/questions/#_1、react事件绑定原理" class="sidebar-link reco-side-_1、react事件绑定原理" data-v-70334359>1、react事件绑定原理</a></li><li class="level-3" data-v-70334359><a href="/docs/questions/#_2、react的事件和普通的html事件有什么不同" class="sidebar-link reco-side-_2、react的事件和普通的html事件有什么不同" data-v-70334359>2、React的事件和普通的HTML事件有什么不同？</a></li><li class="level-3" data-v-70334359><a href="/docs/questions/#合成事件是-react-模拟原生-dom-事件所有能力的一个事件对象-优点" class="sidebar-link reco-side-合成事件是-react-模拟原生-dom-事件所有能力的一个事件对象-优点" data-v-70334359>合成事件是 react 模拟原生 DOM 事件所有能力的一个事件对象 优点</a></li><li class="level-3" data-v-70334359><a href="/docs/questions/#_3、-react-组件中怎么做事件代理-它的原理是什么" class="sidebar-link reco-side-_3、-react-组件中怎么做事件代理-它的原理是什么" data-v-70334359>3、 React 组件中怎么做事件代理？它的原理是什么？</a></li><li class="level-3" data-v-70334359><a href="/docs/questions/#_4、react-高阶组件、render-props、hooks-有什么区别-为什么要不断迭代" class="sidebar-link reco-side-_4、react-高阶组件、render-props、hooks-有什么区别-为什么要不断迭代" data-v-70334359>4、React 高阶组件、Render props、hooks 有什么区别，为什么要不断迭代</a></li><li class="level-3" data-v-70334359><a href="/docs/questions/#_5、对react-fiber的理解-它解决了什么问题" class="sidebar-link reco-side-_5、对react-fiber的理解-它解决了什么问题" data-v-70334359>5、对React-Fiber的理解，它解决了什么问题？</a></li><li class="level-3" data-v-70334359><a href="/docs/questions/#_6、react-component-和-react-purecomponent-的区别" class="sidebar-link reco-side-_6、react-component-和-react-purecomponent-的区别" data-v-70334359>6、React.Component 和 React.PureComponent 的区别？</a></li><li class="level-3" data-v-70334359><a href="/docs/questions/#_7、component-element-instance-之间有什么区别和联系" class="sidebar-link reco-side-_7、component-element-instance-之间有什么区别和联系" data-v-70334359>7、Component, Element, Instance 之间有什么区别和联系？</a></li><li class="level-3" data-v-70334359><a href="/docs/questions/#_8、对componentwillreceiveprops-的理解" class="sidebar-link reco-side-_8、对componentwillreceiveprops-的理解" data-v-70334359>8、对componentWillReceiveProps 的理解</a></li><li class="level-3" data-v-70334359><a href="/docs/questions/#_9、哪些方法会触发-react-重新渲染-重新渲染-render-会做些什么" class="sidebar-link reco-side-_9、哪些方法会触发-react-重新渲染-重新渲染-render-会做些什么" data-v-70334359>9、哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？</a></li><li class="level-3" data-v-70334359><a href="/docs/questions/#_10、react如何判断什么时候重新渲染组件" class="sidebar-link reco-side-_10、react如何判断什么时候重新渲染组件" data-v-70334359>10、React如何判断什么时候重新渲染组件？</a></li><li class="level-3" data-v-70334359><a href="/docs/questions/#_11、对有状态组件和无状态组件的理解及使用场景" class="sidebar-link reco-side-_11、对有状态组件和无状态组件的理解及使用场景" data-v-70334359>11、对有状态组件和无状态组件的理解及使用场景</a></li><li class="level-3" data-v-70334359><a href="/docs/questions/#_12、对react中fragment的理解-它的使用场景是什么" class="sidebar-link reco-side-_12、对react中fragment的理解-它的使用场景是什么" data-v-70334359>12、对React中Fragment的理解，它的使用场景是什么？</a></li><li class="level-3" data-v-70334359><a href="/docs/questions/#_13、在react中如何避免不必要的render" class="sidebar-link reco-side-_13、在react中如何避免不必要的render" data-v-70334359>13、在React中如何避免不必要的render？</a></li><li class="level-3" data-v-70334359><a href="/docs/questions/#_14、对-react-context-的理解" class="sidebar-link reco-side-_14、对-react-context-的理解" data-v-70334359>14、对 React context 的理解</a></li><li class="level-3" data-v-70334359><a href="/docs/questions/#_15、为什么react并不推荐优先考虑使用context" class="sidebar-link reco-side-_15、为什么react并不推荐优先考虑使用context" data-v-70334359>15、为什么React并不推荐优先考虑使用Context？</a></li><li class="level-3" data-v-70334359><a href="/docs/questions/#_16、react中refs的作用是什么-有哪些应用场景" class="sidebar-link reco-side-_16、react中refs的作用是什么-有哪些应用场景" data-v-70334359>16、React中refs的作用是什么？有哪些应用场景？</a></li><li class="level-3" data-v-70334359><a href="/docs/questions/#_17、react组件的构造函数有什么作用-它是必须的吗" class="sidebar-link reco-side-_17、react组件的构造函数有什么作用-它是必须的吗" data-v-70334359>17、React组件的构造函数有什么作用？它是必须的吗？</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><div class="kanbanniang" data-v-5775ee02><div class="banniang-container" style="display:;" data-v-5775ee02><div class="messageBox" style="right:68px;bottom:190px;display:none;" data-v-5775ee02>
      欢迎来到
    </div> <div class="operation" style="right:90px;bottom:40px;display:none;" data-v-5775ee02><i class="kbnfont kbn-ban-home ban-home" data-v-5775ee02></i> <i class="kbnfont kbn-ban-message message" data-v-5775ee02></i> <i class="kbnfont kbn-ban-close close" data-v-5775ee02></i> <a target="_blank" href="https://vuepress-theme-reco.recoluan.com/views/plugins/kanbanniang.html" data-v-5775ee02><i class="kbnfont kbn-ban-info info" data-v-5775ee02></i></a> <i class="kbnfont kbn-ban-theme skin" style="display:none;" data-v-5775ee02></i></div> <canvas id="banniang" width="240" height="352" class="live2d" style="right:90px;bottom:-20px;opacity:0.9;" data-v-5775ee02></canvas></div> <div class="showBanNiang" style="display:none;" data-v-5775ee02>
    看板娘
  </div></div><canvas id="vuepress-canvas-cursor"></canvas><div></div><div class="Sakura" data-v-017cf06a><canvas id="canvas_sakura" style="z-index:-1;" data-v-017cf06a></canvas></div></div></div>
    <script src="/assets/js/app.c16eda41.js" defer></script><script src="/assets/js/4.b5d4bb75.js" defer></script><script src="/assets/js/1.38fca83b.js" defer></script><script src="/assets/js/27.a168590d.js" defer></script>
  </body>
</html>
